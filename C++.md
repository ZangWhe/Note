### 1 左值、右值及其引用的区别

##### 概念

###### **左值**

- 左值既可以出现在等号左边，也能出现在等号右边
- 左值可以修改
- 左值是可寻址的变量，具有持久性

###### **纯右值**

- 右值只能出现在等号右边

- 右值不可修改
- 右值一般是不可寻址的常量，具有临时性

###### **将亡值**

- C++11新增的与右值引用相关的表达式
- 常用来完成移动构造或移动赋值的特殊任务，扮演着“将亡”的角色

- 将亡值定义了这样一种行为：具名的临时值、同时又能够被move。



##### 示例

###### **左值示例**

- 变量名、函数名以及数据成员名
- 返回左值引用的函数调用
- 由赋值运算符或复合赋值运算符连接的表达式，如(a=b, a-=b等)
- 解引用表达式*ptr
- 前置自增和自减表达式(++a, ++b)
- 成员访问（点）运算符的结果
- 由指针访问成员（ `->` ）运算符的结果
- 下标运算符的结果(`[]`)
- 字符串字面值("abc")

###### **纯右值示例**

- 字面值(字符串字面值除外)，例如1，'a', true等
- 返回值为非引用的函数调用或操作符重载，例如：str.substr(1, 2), str1 + str2, or it++
- 后置自增和自减表达式(a++, a--)
- 算术表达式
- 逻辑表达式
- 比较表达式
- lambda表达式

###### **将亡值示例**

- 返回右值引用的函数返回值，如static_cast<T&&>(t)

- 转换为右值引用的转换函数的返回值，如std::move(t)



##### 引用

###### **左值引用**

- 只能引用左值
- 通过&运算符声明

###### **右值引用**

- 只能引用右值

- 通过&&运算符声明



> **C++11的右值引用：**
>
> - 右值引用具有移动语义，可以通过std::move函数将资源的所有权（如动态分配的内存）从一个对象转移到另一个对象，避免了不必要的拷贝和内存分配。
> - 右值引用还使得实现“完美转发”成为可能，也就是将传入的参数原样传递给其他函数，避免了多次拷贝。





##### 文心一言版解释

> 左值引用和右值引用是C++中两种重要的概念，它们的区别和意义如下：
>
> 1. 左值引用和右值引用的区别：
>    - 基本概念：左值是可以放在赋值号左边，可以被赋值的值，它必须有内存实体；而右值是当在赋值号右边取出值赋给其他变量的值，它可以在内存也可以在CPU寄存器。
>    - 操作方式：左值引用是用来改变指针的指向，还可以改变指针所指向的值；右值引用可以用来给左值赋值。
> 2. 右值引用的意义：
>    - 提高效率：通过避免不必要的对象拷贝，节省运算存储资源，提高程序的执行效率。
>    - 简化操作：使得泛型编程更为简洁明确，便于操作。



##### ChatGPT版解释

> 1. 区别：
>
> - 左值引用（lvalue reference）：通过&符号来声明，只能引用左值（具有内存地址的表达式或变量），可以修改左值。
> - 右值引用（rvalue reference）：通过&&符号来声明，只能引用右值（临时或即将销毁的值），可以修改右值。
>
> 2. 右值引用的意义：
>
> - 资源移动：右值引用可以通过std::move函数，将一个对象的资源所有权从一个对象转移到另一个对象，避免了不必要的内存拷贝和分配。
> - 完美转发：右值引用允许我们实现所谓的“完美转发”，即将传入的参数原样传递给其他函数，避免了多次拷贝。
> - 优化性能：右值引用可以避免不必要的对象拷贝和析构，提高程序的性能和效率。



参考文章：

[深入理解左值和右值 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/513628368)





---



### 2 C++内存泄漏

##### 概念

内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。



##### 分类

内存泄漏分为以下两类：

- **堆内存泄漏**：我们经常说的内存泄漏就是堆内存泄漏，在堆上申请了资源，在结束使用的时候，没有释放归还给OS，从而导致该块内存永远不会被再次使用
- **资源泄漏**：通常指的是系统资源，比如socket，文件描述符等，因为这些在系统中都是有限制的，如果创建了而不归还，久而久之，就会耗尽资源，导致其他程序不可用

##### 根源

- **进程内存布局**

![image-20231010160523235](C:\Users\WangZhe\AppData\Roaming\Typora\typora-user-images\image-20231010160523235.png)

​	上图为32位进程的内存布局，从上图中主要包含以下几个块：

​	[内核空间](https://www.zhihu.com/search?q=内核空间&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})：供内核使用，存放的是内核代码和数据

​	stack：这就是我们经常所说的栈，用来存储[自动变量](https://www.zhihu.com/search?q=自动变量&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})([automatic variable](https://www.zhihu.com/search?q=automatic variable&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260}))

​	mmap:也成为[内存映射](https://www.zhihu.com/search?q=内存映射&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})，用来在进程[虚拟内存](https://www.zhihu.com/search?q=虚拟内存&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})地址空间中分配地址空间，创建和[物理内存](https://www.zhihu.com/search?q=物理内存&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})的映射关系

​	heap:就是我们常说的堆，动态内存的分配都是在堆上

​	bss:包含所有未初始化的全局和[静态变量](https://www.zhihu.com/search?q=静态变量&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})，此段中的所有变量都由0或者空[指针初始化](https://www.zhihu.com/search?q=指针初始化&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})，程序加载器在加载程序时为BSS段分配内存

​	data:初始化的数据块

- - 包含显式初始化的[全局变量](https://www.zhihu.com/search?q=全局变量&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})和静态变量

  - 此段的大小由[程序源代码](https://www.zhihu.com/search?q=程序源代码&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})中值的大小决定，在运行时不会更改

  - 它具有读写权限，因此可以在运行时更改此段的变量值

  - 该段可进一步分为[初始化只读区](https://www.zhihu.com/search?q=初始化只读区&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})和初始化读写区


​	text：也称为文本段

- - 该段包含已编译程序的[二进制文件](https://www.zhihu.com/search?q=二进制文件&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})。
  - 该段是一个只读段，用于防止程序被意外修改
  - 该段是可共享的，因此对于[文本编辑器](https://www.zhihu.com/search?q=文本编辑器&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})等频繁执行的程序，内存中只需要一个副本

- **内存分配**

  - **静态分配**

    编译时分配。包括:全局、静态全局、静态局部三种变量。

  - **动态分配**

    堆上通过malloc函数进行内存的动态分配，通过malloc（new）函数分配的内存需要开发人员通过free（delete）函数手动释放，因此容易发生内存泄漏

    栈上通过alloca函数进行内存的动态分配，通过alloca函数分配的内存由编译器进行释放，无需手动操作


- **堆和栈的区别**

​	**空间大小不同**

​	一般来讲在 32 位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。

​	对于栈来讲，一般都是有一定的空间大小的，一般依赖于操作系统(也可以人工设置)

​	**能否产生碎片不同**

​	对于堆来讲，频繁的内存分配和释放势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。

​	对于栈来讲，内存都是连续的，申请和释放都是指令移动，类似于[数据结构](https://www.zhihu.com/search?q=数据结构&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})中的进栈和出栈

​	**增长方向不同**

​	对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向

​	对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长

​	**分配方式不同**

​	堆都是动态分配的，比如我们常见的malloc/new；而栈则有静态分配和动态分配两种。

​	静态分配是编译器完成的，比如局部变量的分配，而栈的动态分配则通过alloca()函数完成

​	二者动态分配是不同的，栈的动态分配的内存由编译器进行释放，而堆上的动态分配的内存则必须由开发人自行释放

​	**分配效率不同**

​	栈有操作系统分配专门的[寄存器](https://www.zhihu.com/search?q=寄存器&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高

​	堆内存的申请和释放专门有运行时库提供的函数，里面涉及复杂的逻辑，申请和释放效率低于栈



##### 内存泄漏产生方式

- 常发性内存泄漏

​	产生内存泄漏的代码或者函数会被多次执行到，在每次执行的时候，都会产生内存泄漏

- 偶发性内存泄漏

​	偶发性内存泄漏函数只在特定的场景下才会被执行。

- 一次性内存泄漏

​	偶发性内存泄漏函数只在特定的场景下才会被执行。

- 隐式内存泄漏

​	程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。



##### 内存泄漏产生原因

- **未释放**

如下代码所示，申请内存后，没有调用free函数进行释放，造成内存泄漏

```C
int fun() {
    char * pBuffer = malloc(sizeof(char));
    
    /* Do some work */
    return 0;
}
```

或者是下面代码中，析构函数没有释放掉为成员变量申请的动态内存

```C
class Obj {
 public:
   Obj(int size) {
     buffer_ = new char;
   }
   ~Obj(){}
  private:
   char *buffer_;
};

int fun() {
  Object obj;
  // do sth
  return 0;
}
```

- **未匹配**

  - new和free

  ```C
  Test *t = new Test;
  free(t)
  ```

  此处会产生内存泄漏。new操作符会先通过operator new分配一块内存，然后在该块内存上调用placement new即调用Test的构造函数。而在上述代码中，只是通过free函数释放了内存，但是没有调用Test的析构函数以释放Test的成员变量，从而引起内存泄漏。

  - new[]和delete

  ```C
  int main() {
    Test *t = new Test [10];
    // do sth
    delete t;
    return 0;
  }
  ```

  在上述代码中，我们通过new创建了一个Test类型的数组，然后通delete操作符删除该数组，编译并执行，输出如下：

  ```C
  in Test
  in Test
  in Test
  in Test
  in Test
  in Test
  in Test
  in Test
  in Test
  in Test
  in ~Test
  ```

  从上面输出结果可以看出，调用了10次构造函数，但是只调用了一次析构函数，所以引起了内存泄漏。这是因为调用delete t释放了通过operator new[]申请的内存，即malloc申请的内存块，且只调用了t[0]对象的析构函数，t[1..9]对象的析构函数并没有被调用。

- **虚析构**

在C++中，虚析构函数是一种特殊的析构函数，用于在派生类对象被删除时正确释放资源。当基类指针指向派生类对象并删除该指针时，如果基类的析构函数不是虚构函数，那么只会调用基类的析构函数，而不会调用派生类的析构函数，这可能导致派生类特有的资源无法正确释放，造成内存泄漏。

为了解决这个问题，可以将基类的析构函数声明为虚析构函数，即在基类的析构函数前加上关键字"virtual"。这样，当基类指针指向派生类对象并删除该指针时，会先调用派生类的析构函数，然后再调用基类的析构函数，从而正确释放派生类特有的资源。

虚析构函数的一般语法如下：

```cpp
class Base {
public:
    virtual ~Base() {
        // 基类析构函数的实现
    }
};

class Derived : public Base {
public:
    ~Derived() override {
        // 派生类析构函数的实现
    }
};
```

> 需要注意的是，派生类的析构函数可以选择是否加上"override"关键字，但建议加上以提高代码的可读性和可维护性。同时，由于虚析构函数会增加额外的开销，只有在需要通过基类指针删除派生类对象时才需要使用虚析构函数。

**存在继承关系的情况下，构造函数和析构函数的调用顺序**

​	派生类对象在创建时构造函数调用顺序：

1. 调用父类的构造函数
2. 调用父类成员变量的构造函数
3. 调用派生类本身的构造函数

​	派生类对象在析构时的析构函数调用顺序：

1. 执行派生类自身的析构函数
2. 执行派生类成员变量的析构函数
3. 执行父类的析构函数



- **循环引用**

​		循环引用问题在C++中是指当两个或多个对象互相持有对方的引用（通常是通过[智能指针](https://so.csdn.net/so/search?q=智能指针&spm=1001.2101.3001.7020)），导致它们的引用计数永远不会降为零，从而导致内存泄漏的情况。这种问题在使用`shared_ptr`时尤为突出，因为`shared_ptr`会自动管理对象的生命周期并维护引用计数。

​		比如：

```C
class A {
public:
    std::shared_ptr<B> b_ptr;
};
 
class B {
public:
    std::shared_ptr<A> a_ptr;
};
```

​		当创建A,B对象时，并使他们相互引用

```C
std::shared_ptr<A> a = std::make_shared<A>();
std::shared_ptr<B> b = std::make_shared<B>();
a->b_ptr = b;
b->a_ptr = a;
```

​		在这个例子中，A对象持有B对象的`shared_ptr`，B对象持有A对象的`shared_ptr`。这会导致循环引用，因为A和B的引用计数都为1，它们都不会被自动销毁。这种情况下，即使`shared_ptr`超出其作用域，相关对象也不会被释放，从而导致[内存泄漏](https://so.csdn.net/so/search?q=内存泄漏&spm=1001.2101.3001.7020)。

为了解决循环引用问题，我们可以将B类中的`shared_ptr<A>`替换为`weak_ptr<A>`，这样就可以打破循环引用：

```C
class B {
public:
    std::weak_ptr<A> a_ptr;
};
```

> 需要注意的是，`weak_ptr`无法直接访问其指向的对象。要访问对象，必须先将`weak_ptr`转换为`shared_ptr`，这可以通过`lock()`成员函数实现。同时，在访问之前，可以使用`expired()`成员函数检查`weak_ptr`是否悬空，以确保安全访问。

##### 如何避免内存泄漏

- **避免在堆上分配**

​		大部分的内存泄漏都是在堆上分配引起的，但如果实际应用场景中可以不用到堆，比如对象可以在栈上分配，一方面栈的效率高于堆，另一方面，还能避免内存泄漏。

- **手动释放**
  - 对于[malloc函数](https://www.zhihu.com/search?q=malloc函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})分配的内存，在结束使用的时候，使用free函数进行释放
  - 对于new操作符创建的对象，切记使用delete来进行释放
  - 对于new []创建的对象，使用delete[]来进行释放(使用free或者delete均会造成内存泄漏)
- **避免使用裸指针**
- **使用STL库**

​	如std::vector或std::array代替C语言数组，使用std::string代替char*等

- **智能指针**

  - unique_ptr

    unique_ptr是限制最严格的一种智能指针，用来替代之前的auto_ptr，独享被管理对象指针所有权。当unique_ptr对象被销毁时，会在其析构函数内删除关联的原始指针。

  - shared_ptr

    shared_ptr是共享管理权，即多个shared_ptr可以共用同一块关联对象，其内部采用的是引用计数，在拷贝的时候，引用计数+1，而在某个对象退出作用域或者释放的时候，引用计数-1，当引用计数为0的时候，会自动释放其管理的对象。

  - weak_ptr

    weak_ptr是智能指针中最弱的一个，weak_ptr只能访问所指向的内存区域，当weak_ptr生命周期结束的时候，其所指向的内存依旧完好无损。weak_ptr主要与shared_ptr一起使用。

    > 引用计数指针的本质是”在内存需要析构时，引用及技术指针的计数值不断的减1直到为0，从而对内存进行析构“，但是weak_ptr不会影响shared_ptr引用计数指针的计数值，即weak_ptr不会影响到只想去与内存的生命周期
    >
    > 因此这也就是weak_ptr不会导致无限循环释放的错误；

- **RAII**

​	RAII是Resource Acquisition is Initialization(资源获取即初始化)的缩写，是C++语言的一种管理资源，避免泄漏的用法。

​	利用的就是C++构造的对象最终会被销毁的原则。利用C++对象生命周期的概念来控制程序的资源,比如内存,[文件句柄](https://www.zhihu.com/search?q=文件句柄&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260}),网络连接等。

​	RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命周期内控制对资源的访问，使之始终保持有效，最后在对象析构	的时候，释放构造时获取的资源。

​	简单地说，就是把资源的使用限制在对象的生命周期之中，自动释放。



##### 如何定位内存泄漏

- 日志

​		这种方案的核心思想，就是在每次分配内存的时候，打印指针地址，在释放内存的时候，打印内存地址，这样在程序结束的时候，通过分配和释放的差，如果分配的条数大于释放的条数，那么基本就能确定程序存在内存泄漏，然后根据日志进行详细分析和定位。

```C
char * fun() {
  char *p = (char*)malloc(20);
  printf("%s, %d, address is: %p", __FILE__, __LINE__, p);
  // do sth
  return p;
}

int main() {
  fun();
  
  return 0;
}
```

- **统计**

​	统计方案可以理解为日志方案的一种特殊实现，其主要原理是在分配的时候，统计分配次数，在释放的时候，则是统计释放的次数，这样在程序结束前判断这俩值是否一致，就能判断出是否存在内存泄漏。

​	此方法可帮助跟踪已分配内存的状态。为了实现这个方案，需要创建三个自定义函数，一个用于内存分配，第二个用于内存释放，最后一个用于检查内存泄漏。

- **工具**

  - valgrind

  - mtrace

  - dmalloc

  - ccmalloc

  - memwatch

  - debug_new

##### 参考文章

[C++ 怎么检测内存泄露，怎么定位内存泄露？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/63946754/answer/2973245260)

[深入理解C++中的循环引用问题及解决方法_c++循环引用_adam2021的博客-CSDN博客](https://blog.csdn.net/adam2021/article/details/129849022)



---

###  3 const char *p 、 char const *p 与 char * const p的区别

const修饰的位置不同，会对指针p的性质产生不同的影响。

##### const char *p

指针p指向的是一个常量字符，即p所指向的字符内容不能通过指针p来修改，但是指针p可以指向其他的字符。

例如：

```C++
const char *p = "Hello"; // p指向一个字符串常量，不能通过p修改字符内容
```

p = "World"; // 可以将p指向"World"

##### char const *p

与const char *p相同，指针p也指向的是一个常量字符，即p所指向的字符内容不能通过指针p来修改，但是指针p可以指向其他的字符。

##### char * const p

指针p本身是一个常量指针，即p的值不能改变，它始终指向一个固定的地址，但是该地址中的字符内容可以通过指针p进行修改。

例如：

```c++
char str1[] = "Hello";
char * const p = str1; // p是一个常量指针，始终指向str1的地址
p[0] = 'h'; // 可以通过p来修改str1的字符内容
char str2[] = "World";
//p = str2; // 不能修改指针p的值，会报错
```



> 总结：const char *p 和 char const *p 是等价的，指针p指向的是一个常量字符；而char * const p是一个常量指针，指针p自身的值不能改变，但是可以通过指针p来修改字符内容。





---



### 4 static_cast、dynamic_cast、reinterpret_cast 和 const_cast的区别

##### static_cast

用于基本类型之间的强制类型转换，以及具有继承关系的指针或引用之间的转换。它在**编译时**进行类型检查，不会进行dynamic_cast所需的运行时类型检查。

##### dynamic_cast

用于具有继承关系的指针或引用之间的转换，可以在**运行时**检查对象的类型是否能够转换成功。它只能用于具有虚函数的类（即多态类型），可以在将多态类型的指针或引用转换为其派生类指针或引用时使用。如果转换是不安全的，dynamic_cast返回一个空指针（对指针）或抛出一个std::bad_cast异常（对引用）。

##### reinterpret_cast

用于不同类型的指针、引用或任意类型之间的转换，它提供了一种底层的重新解释目标类型的方法，但是很容易导致未定义行为。reinterpret_cast不会进行任何类型检查，因此需要谨慎使用。

##### const_cast

用于添加或移除const、volatile修饰符，通常用于去除const限定，使一个const对象变为非常量。const_cast只能操作指针或引用，不能用于按值的变量。需要注意的是，const_cast只能改变底层对象的const性质，不能用于改变底层对象类型。



---



### 5 C++静态多态和动态多态

C++中的多态是指同一函数可以根据调用的对象的实际类型来执行不同的操作。多态通过基类指针或引用调用派生类对象的成员函数，实现对不同类型的对象的统一操作。

C++中的多态有两种实现方式：编译时多态（静态多态）和运行时多态（动态多态）。

1. 编译时多态（静态多态）：
   - 函数重载：在同一作用域内，相同函数名但参数列表不同的函数可以有多个版本，编译器根据实参的类型来决定调用哪个函数。
   - 模板：使用通用的算法实现，根据实际参数的类型在编译时将相应的代码生成。
2. 运行时多态（动态多态）：
   - 虚函数（虚函数重写）：使用基类的指针或引用调用派生类的重写函数，实际调用的是派生类中与基类虚函数同名的函数。通过将基类的函数声明为虚函数，在运行时确定调用的是哪个类的函数，实现多态性。
   - 动态绑定：使用基类指针或引用调用派生类对象的函数时，会在运行时动态绑定到正确的成员函数上，实现函数的动态调用。



---



### 6 enable_shared_from_this是什么

##### 概述

`enable_shared_from_this` 是 C++ 标准库提供的一个模板类，位于 `<memory>` 头文件中。它用于解决由于对象被 `shared_ptr` 管理内存导致的问题，即在对象中获取自身的 `shared_ptr`。

当某个类继承自 `enable_shared_from_this` 时，该类的对象可以通过调用`shared_from_this()`函数来获取一个指向自己的 `shared_ptr`。这样，在对象被 `shared_ptr` 管理时，可以避免手动创建一个新的 `shared_ptr` 导致的内存泄漏或对象的多个 `shared_ptr` 不一致的问题。

使用 `enable_shared_from_this` 的关键是避免直接通过构造函数创建一个 `shared_ptr`，而是通过类内部的成员函数获取指向自身的 `shared_ptr`。这样可以确保 `shared_ptr` 的计数器被正确维护，避免多个 `shared_ptr` 对同一个对象进行资源管理而导致的问题。

使用 `enable_shared_from_this` 可以更方便地在对象中获取到指向自身的 `shared_ptr`，避免手动管理对象的生命周期，提高代码	的可维护性和安全性。

##### 使用条件

1. 对象必须是由 `shared_ptr` 管理的，不能使用 `unique_ptr` 或者原始指针。
2. 在对象中不能直接或间接创建一个新的 `shared_ptr`，否则会引发 `std::bad_weak_ptr` 异常。
3. 调用 `shared_from_this()` 时，必须保证对象已经被至少一个 `shared_ptr` 管理，否则会导致 `std::bad_weak_ptr` 异常的发生。



##### 使用步骤

要使用 `enable_shared_from_this`，需要遵循以下步骤：

1. 定义一个类，并使其继承自 `std::enable_shared_from_this`：

```c++
class MyClass : public std::enable_shared_from_this<MyClass> {
  // 类的成员和方法
};
```

2. 在需要获取指向自身的 `shared_ptr` 的地方，调用 `shared_from_this()` 方法：

```c++
std::shared_ptr<MyClass> obj = std::make_shared<MyClass>();
std::shared_ptr<MyClass> sharedPtr = obj->shared_from_this();
```



---

### 7 常量指针和指针常量的区别

1. 常量指针（Const Pointer）：
   常量指针是指向常量的指针。它不能改变所指向的值，但可以改变指针本身的值，也就是让它指向其他的内存地址。例如：

```cpp
const int *p = &a; // p指向a，不能通过p改变a的值，但可以改变p指向的其他变量
```

这意味着，你可以改变指针 `p` 所指向的地址，但不能通过 `p` 来改变它所指向的变量的值。

2. 指针常量（Pointer Constant）：
   指针常量是指针本身是常量，即指针不能改变，而指针所指向的值可以改变。例如：

```cpp
int * const p = &a; // p是一个常量指针，不能改变p的值，但可以改变p所指向的变量的值
```

这意味着，你不能改变指针 `p` 的地址（即不能让 `p` 指向其他的变量），但可以通过 `p` 来改变它所指向的变量的值。

总结一下，"常量指针"是一个指向常量的指针，它不能通过这个指针来改变所指向的变量的值；而"指针常量"则是一个指针本身是常量，即它不能指向其他的变量，但可以通过这个指针来改变它所指向的变量的值。



---



### 8 为什么auto_ptr会被弃用

`auto_ptr` 在 C++98 标准中是一个常用的智能指针类型，它可以在超出作用域时自动删除它所拥有的对象。然而，它在 C++11 中被弃用，并在 C++17 中被移除，主要有以下几个原因：

1. **所有权问题**：`auto_ptr` 的一个主要问题是它不能很好地支持STL容器。当多个 `auto_ptr` 指向同一个对象时，删除其中一个并不会删除其他 `auto_ptr` 所指向的对象，这导致了内存泄漏。这是因为在 C++98 中，`auto_ptr` 并不支持所有权的概念。
2. **不适用于数组**：`auto_ptr` 在处理动态分配的数组时也有问题。当 `auto_ptr` 被删除时，它只会删除第一个元素，而不会删除整个数组，这可能导致内存泄漏。
3. **不适用于自定义类型**：`auto_ptr` 在处理自定义类型时可能会出现问题。如果一个类型的析构函数抛出一个异常，那么 `auto_ptr` 会删除它所指向的对象，然后再删除一次，这可能导致未定义的行为。
4. **所有权转移**：`auto_ptr` 不支持所有权转移。这意味着你不能把一个 `auto_ptr` 的所有权从一个变量转移到另一个变量。这限制了 `auto_ptr` 的使用场景。

为了解决上述问题，C++11引入了新的智能指针类型 `std::unique_ptr` 和 `std::shared_ptr`。这两个类型可以更好地管理动态分配的内存，支持所有权的概念，并且可以很好地与 STL 容器集成。因此，`auto_ptr` 被弃用并最终从标准库中移除也就理所当然了



---



### 9 new/delete与malloc/free的区别

`new` 和 `delete` 是 C++ 中用于动态分配和释放对象的运算符，而 `malloc` 和 `free` 是 C 语言中用于动态分配和释放内存的函数。它们之间存在以下几个区别：

1. **类型安全性**：`new` 和 `delete` 是类型安全的，它们会根据类型进行内存分配和释放，并在分配对象时调用构造函数，在释放对象时调用析构函数。而 `malloc` 和 `free` 是无类型的，它们只是在字节级别进行内存分配和释放，不会调用构造函数和析构函数。
2. **内存分配大小**：`new` 运算符根据指定的类型自动计算所需的内存大小，而 `malloc` 函数需要手动指定所需的字节数。例如，`new int` 分配一个 `int` 大小的内存，而 `malloc(sizeof(int))` 需要手动指定所需的字节数。
3. **异常处理**：`new` 运算符在分配内存失败时，会抛出 `std::bad_alloc` 异常，以便于异常处理。而 `malloc` 函数在分配内存失败时，返回 `NULL`。
4. **自定义类型支持**：`new` 可以分配自定义类型的内存，并在分配时调用构造函数。而 `malloc` 只能分配字节大小的内存块。

总之，`new` 和 `delete` 是 C++ 中的运算符，提供了更高级、类型安全和自动处理的内存分配和释放机制。而 `malloc` 和 `free` 则是 C 语言中的函数，更为底层、无类型且手动指定内存字节数。建议在 C++ 中优先使用 `new` 和 `delete`，除非有特定的兼容性或其他原因需要使用 `malloc` 和 `free`。



---



### 10 内联函数是怎么实现的，有什么优缺点

##### 概念

内联函数是一种编译器优化技术，用于将函数的代码直接插入到函数调用的地方，而不是通过函数调用的方式进行执行。

##### 实现

内联函数的实现方式主要包括以下两个步骤：

1. 内联声明：在函数声明前加上 `inline` 关键字，告诉编译器将该函数作为内联函数进行处理。内联声明通常放在头文件中，以便在需要时在多个编译单元间共享。
2. 内联展开：编译器在编译过程中遇到内联函数的调用时，将函数的定义直接插入到调用处，替代函数调用的过程。这样，函数的执行就不再通过跳转到函数体的方式，而是直接在调用地点展开执行。

##### 优点

1. 减少函数调用开销：内联函数的内部代码直接嵌入到调用处，避免了函数调用的开销，如栈帧的创建与销毁、参数传递和跳转。
2. 提高代码执行速度：由于内联函数的代码直接展开，消除了函数调用时的跳转和返回过程，可以减少指令跳转带来的延迟，从而提高代码的执行速度。
3. 可以进行更多的编译器优化：内联函数在展开时，编译器能够对其进行更多的优化，如常量折叠、循环展开、无用代码消除等。

##### 缺点

1. 增大代码体积：由于内联函数在调用处展开，会增加代码的重复性，导致可执行文件的体积增大。
2. 增加编译时间：内联函数在每个调用处都需要重新展开，会增加编译时间，尤其是对于大型项目。
3. 可能导致缓存失效：代码展开可能导致指令和数据的增加，使得缓存命中率下降，影响代码的执行效率。

> 在实际使用中，适合内联的函数通常是短小且频繁调用的函数。



---

### 11 this指针

在C++中，`this` 是一个指向当前对象的指针。它是每个非静态成员函数（包括成员函数、成员方法和成员重载运算符）的一个隐式参数，用于指向调用该函数的对象本身。

`this` 指针的作用是允许在类的成员函数中访问和操作当前对象的成员变量和成员函数。通过 `this` 指针，可以区分对象的成员和同名的局部变量或参数，避免命名冲突。

当调用一个对象的成员函数时，编译器会自动将对象的地址传递给 `this` 指针。通过 `this` 指针，可以访问对象的成员变量和成员函数，如 `this->member`（`(*this).member`） 或 `this->method()`。

以下是 `this` 指针的一些特点和使用注意事项：

1. `this` 指针是指向当前对象的常量指针，不允许修改其值。因此，不能将 `this` 指针赋值给其他指针变量。
2. `this` 指针只能在非静态成员函数中使用，静态成员函数没有 `this` 指针。
3. `this` 指针可以在成员函数中进行显式引用，也可以省略不写，编译器会自动添加。
4. `this` 指针可以作为隐式参数传递给其他函数，以便在其他函数中访问当前对象。

使用 `this` 指针可以在类的成员函数中方便地访问和操作对象的成员，特别是在处理成员变量和成员函数名称冲突时非常有用。

> 在C++中，`this` 是一个指向当前对象的指针，它是一个**右值**（rvalue）。
>
> 由于 `this` 是一个右值，因此不能对它进行赋值或修改。它只能用于访问成员



---

### 12 深拷贝和浅拷贝

深拷贝（Deep Copy）和浅拷贝（Shallow Copy）是在C++中用于复制对象或数据的两种不同方式。

1. 浅拷贝：
   浅拷贝是一种简单的复制操作，它只复制数据成员本身，而不复制指向的数据或对象。即使在复制后，原对象和副本对象仍然共享相同的资源。在浅拷贝中，默认情况下，编译器会提供默认的拷贝构造函数和赋值运算符重载函数，它们会逐个复制数据成员的值。
2. 深拷贝：
   深拷贝是一种复制操作，它会复制所有的数据成员，包括指向的数据或对象。深拷贝创建了一个新的对象，并为新对象的指针成员分配独立的内存。在深拷贝中，开发者需要自定义拷贝构造函数和赋值运算符重载函数，以确保所有指针成员都进行独立的内存分配和复制。

深拷贝的优势在于它创建了完全独立的拷贝，并且避免了多个对象之间共享资源的问题。每个对象都有自己的独立拷贝，修改一个对象不会影响其他对象

---

### 13 虚函数及其工作机制

虚函数是C++中的一种特殊函数，被声明为虚函数后，它可以在派生类中被重写（override）以实现运行时多态性。虚函数通过运行时动态绑定的机制，使得程序能够根据对象的实际类型来调用相应的函数。

虚函数的工作机制如下：

1. 定义及声明：在基类中，我们可以通过在函数的声明前面加上 `virtual` 关键字来将其声明为虚函数。例如：

```c++
class Base {
public:
    virtual void function(); // 声明为虚函数
};
```

2. 虚函数表：每个有虚函数的类都会维护一个虚函数表（vtable），该表是一个特殊的查找表，存储了虚函数的地址。每个对象（实例）都具有一个指向该虚函数表的隐藏指针（通常称为虚表指针 vptr）。

3. 动态绑定：当调用一个虚函数时，实际调用的是对象的运行时类型所对应的函数。编译器将根据对象的 vptr，从其所属类的虚函数表中找到对应的函数地址，确保调用的是正确的函数版本。

4. 多态性：由于基类指针或引用可以指向派生类对象，通过使用虚函数，我们可以通过基类指针或引用调用相应的派生类函数。而实际调用的函数（派生类中的重写函数）是根据对象的实际类型决定的。这就实现了多态性，即相同的函数调用可以在不同的派生类对象中产生不同的行为。



---

### 14 strlen,sizeof,lengh,size的区别

`strlen`、`sizeof`、`length`、`size` 是 C++ 中常用的用于获取字符串或数据大小的函数或运算符。

1. strlen：`strlen` 是 C 语言中的函数，用于获取以 null 终止的字符串的长度（不包括 null 终止符）。它在 `<cstring>` 头文件中定义。例如，`strlen("Hello")` 将返回 5。
2. sizeof：`sizeof` 是 C++ 中的运算符，用于获取数据类型或变量的字节大小。它返回编译时计算出的值，不需要实际执行代码。例如，`sizeof(int)` 返回整型 `int` 的字节大小。`sizeof` 运算符可以用于任何数据类型、变量或表达式。
3. length：`length` 是 C++ 的字符串类（如 `std::string`）的成员函数，用于获取字符串的长度。它返回字符串的字符数量。例如，`std::string str = "Hello";` 可以使用 `str.length()` 获取字符串的长度。
4. size：`size` 是 C++ 的容器类（如 `std::vector`、`std::array`）的成员函数，用于获取容器中元素的数量。它返回容器的实际大小。例如，`std::vector<int> vec = {1, 2, 3};` 可以使用 `vec.size()` 获取容器中元素的数量。

**总结：**

- `strlen` 用于获取 null 终止的字符串的长度。
- `sizeof` 用于获取数据类型或变量的字节大小。
- `length` 是字符串类的成员函数，用于获取字符串的长度。
- `size` 是容器类的成员函数，用于获取容器中元素的数量。



---



### 15 C++的源代码是如何编译成可执行文件的，说出详细的编译过程

C++源代码编译成可执行文件的过程可以分为预处理、编译、汇编和链接四个阶段：

- **预处理阶段**：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。

- **编译阶段**：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件

- **汇编阶段**：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件

- **链接阶段**：将多个目标文件及所需要的库连接成最终的可执行目标文件

  

---

### 16 C++中如何定义一个只能在堆或只在栈上创建对象的类



- **只在堆上创建对象**

在C++中，类的创建分为两种。一种是静态创建，即直接创建对象，如T *t；另一种是动态创建对象，即通过 new 创建，如 T *t = new T。要想正确回答上题，就必须知道这两种创建方式的区别。

1. **静态创建**

​	由编译器在栈中为对象分配内存，通过移动栈顶指针获得合适大小的空间，然后**调用对象的构造函数**生成对象。

2. **动态创建**

​	通过new在堆中创建对象。这个过程分为两步：首先在堆中找到合适大小的空间并分配，然后**调用对象的构造函数**生成对象。

所以通过将构造函数私有化的做法是行不通的。

> **静态创建的特点**
>
> 编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。

所以只需要将**析构函数私有化**就可以组织直接创建对象了。由于栈的创建和释放都需要由系统完成的，所以若是无法调用构造或者析构函数，自然会报错。

```c++
#include<iostream>
using namespace std;
class test
{
private:
	~test(){ cout << "test destroy" << endl; }
public:
	void destroy()
	{
		delete this;
	}
};
int main()
{
	//test p;//编译器报错test::~test()不可访问
	test *p = new test;
	p->destroy();
}
```

- **只在栈上创建对象**

将 **new操作符重载并设置为私有访问**即可

```c++
#include<iostream>
using namespace std;
class test
{
private:
	void* operator new(size_t t){}
	void operator delete(void* ptr){}
public:
	~test()
	{
		cout << "test destroy" << endl;
	}
};
int main()
{
	//test *A = new test;
	//编译器报错函数test::operator new 不可访问
	test A;
}
```



---



### 17 explicit关键字的作用

`explicit` 关键字在 C++ 中用于修饰**单参数构造函数**（构造函数只接受一个参数），其作用是防止编译器在某些隐式类型转换的情况下自动调用该构造函数。

> 因为无参构造函数和多参构造函数本身就是显示调用的，加上 explicit 关键字也没意义。

具体来说，当类的构造函数被声明为 `explicit` 时，在使用该构造函数进行对象初始化时，必须使用显式的构造函数调用语法，而不是隐式的转换。这样可以避免意外的类型转换，提高代码的可读性和安全性。

下面是一个使用 `explicit` 关键字的示例：

```c++
class MyClass {
public:
    explicit MyClass(int value) {
        // 构造函数的实现
    }
};

void foo(MyClass obj) {
  // 函数的实现
}

int main() {
    MyClass obj1(10); // 通过显式构造函数调用进行对象初始化
    MyClass obj2 = 20; // 错误！禁止隐式类型转换
    foo(30); // 错误！禁止隐式类型转换

    return 0;
}
```

在上述示例中，构造函数 `MyClass(int value)` 声明为 `explicit`，因此在对象初始化时必须使用显式构造函数调用语法，如 `MyClass obj1(10)`。而尝试使用隐式类型转换，如 `MyClass obj2 = 20` 或 `foo(30)`，都会导致编译错误。

通过使用 `explicit` 关键字，可以显式地指定需要进行类型转换的地方，避免了一些潜在的错误和混淆。但需要注意，`explicit` 关键字只对单参数构造函数有效，不适用于无参构造函数或多参数构造函数。



---

### 18 c++中构造函数和析构函数可以抛出异常吗

在 C++ 中，构造函数和析构函数可以抛出异常。构造函数在对象实例化期间可能遇到错误，因此可以使用异常来处理这些错误。析构函数在对象生命周期结束时执行清理工作，也可以通过异常处理来处理清理过程中的错误情况。

然而，需要注意以下几点：

1. 当构造函数抛出异常时，对象的创建过程会被中断，对象将不会被完全构造，并立即销毁。在这种情况下，要注意处理局部对象和已分配的资源，以避免资源泄露。
2. 对象的析构函数在出现异常时也可以抛出异常。但建议在析构函数中避免抛出异常，因为当一个异常在析构函数中被抛出时，如果同时有其他异常未被处理，程序将终止。
3. 在异常处理过程中，应该小心处理可能发生的资源泄露和状态不一致等问题，以确保程序的正确和稳定。

总之，构造函数和析构函数都可以抛出异常，但在使用时需要特别小心，确保在异常情况下能够正确处理资源和状态。需要根据具体的需求和情况来决定是否抛出异常，并进行必要的异常处理。



---



### 19 C++大小端是什么，如何写代码测试大小端

大小端（Endian）是指在多字节数据存储时，字节的顺序是从高位到低位（大端）还是从低位到高位（小端）。

在小端系统中，低位字节存储在内存的低地址，高位字节存储在内存的高地址。而在大端系统中，高位字节存储在内存的低地址，低位字节存储在内存的高地址。

为了测试当前系统的大小端模式，可以编写如下的代码：

```c++
#include <iostream>

int main() {
    unsigned int value = 0x12345678;
    unsigned char* ptr = reinterpret_cast<unsigned char*>(&value);

    if (*ptr == 0x78) {
        std::cout << "Little Endian" << std::endl;
    } else {
        std::cout << "Big Endian" << std::endl;
    }

    return 0;
}
```

上述代码创建了一个无符号整型变量 `value`，初始化为 0x12345678。然后通过将 `value` 的地址转换为 `unsigned char*` 类型的指针 `ptr`，并取指针指向的值，来获取内存中的字节序。如果 `*ptr` 的值为 0x78，则表示系统是小端模式；否则为大端模式。



---

### 20 多继承有什么问题以及如何解决

多继承是 C++ 中的一项特性，允许一个类从多个基类派生。然而，多继承也会引入一些问题。

其中一个常见的问题是菱形继承问题（Diamond Inheritance Problem），也称为菱形继承二义性（Diamond Inheritance Ambiguity）。这种情况发生在一个派生类同时从两个不同的基类继承，而这两个基类又共同继承自同一个基类。这样就会在派生类中出现两个来自基类的相同成员，导致二义性。

例如，考虑以下类继承关系：

```c++
class A {
public:
    int x;
};

class B : public A {
public:
    // 可能有其他成员
};

class C : public A {
public:
    // 可能有其他成员
};

class D : public B, public C {
public:
    // 可能有其他成员
};
```

在这个例子中，类 D 继承自类 B 和类 C，而类 B 和类 C 都继承自类 A。现在，类 D 就会具有两个名为 `x` 的成员变量，一个是从类 B 中继承来的，另一个是从类 C 中继承来的，这就导致了二义性。

为了解决菱形继承问题，C++ 提供了以下解决方案：

1. 使用虚继承（Virtual Inheritance）：通过在类 B 和类 C 继承类 A 的声明中添加 `virtual` 关键字，可以使用虚继承来确保只有一个类 A 的实例被创建。这样就可以避免菱形继承问题。例如，`class B : public virtual A` 和 `class C : public virtual A`。
2. 解决二义性：如果不使用虚继承，而出现了菱形继承问题，可以在派生类 D 中使用作用域限定符来解决二义性问题。例如，可以通过 `D::B::x` 和 `D::C::x` 来访问不同的成员变量。

这些解决方案都是为了消除菱形继承引起的二义性问题，具体需要根据实际情况来选择合适的解决方案。



---



### 21 什么是虚函数表

虚函数表（Virtual Function Table，简称 vtable）是 C++ 中实现多态性的一种机制之一。它用于解决在继承关系中，通过基类指针或引用调用派生类的虚函数时的函数分派问题。

虚函数表是每个含有虚函数的类的一个隐藏的数据结构，通过该表来存储和管理虚函数的地址。每个对象实例都有一个指向对应类的虚函数表的指针，称为虚函数表指针（vptr）。

虚函数表由编译器在编译阶段生成，通常是作为类的静态成员变量。每个类的虚函数表存储了该类的虚函数的地址，以及其他关于虚函数调用的信息。

当通过基类指针或引用调用虚函数时，编译器会根据虚函数表指针的值，动态地确定调用哪个类的虚函数。具体的过程如下：

1. 编译器通过基类指针或引用找到虚函数表指针。
2. 根据虚函数表指针找到对应的虚函数表。
3. 根据函数的索引或偏移量，从虚函数表中找到要调用的虚函数的地址。
4. 调用对应的虚函数。

通过虚函数表的机制，C++ 实现了运行时多态性（Runtime Polymorphism），即通过基类指针或引用调用相应的派生类的虚函数，实现了动态的函数分派和多态行为。

需要注意的是，虚函数表是编译器和实现相关的细节，具体的实现方式可能因编译器和操作系统的不同而有所区别。不同编译器和不同环境下，虚函数表的结构和存储方式可能会有所差异。但总体原理和作用是相似的。



---

### 22 多态、虚继承、多重继承的内存布局

[c++头脑风暴-多态、虚继承、多重继承内存布局 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/381390142)

1. 一个没有虚函数的类，它的大小其实就是所有成员变量的大小，此时它就是一个由诸多成员变量组成的结构体，计算大小时同样要按照字节对齐去计算，下面所有计算大小都需按照字节对齐去计算，后面不再说明；
2. 一个没有虚函数的类派生出一个没有虚函数的派生类，那么这个派生类的内存布局就是先基类成员变量，然后派生类成员变量组成的结构体，各成员变量在内存中存储顺序按照声明时的顺序来存放；
3. 一个有虚函数的类，类本身会生成一份虚函数表，这个虚函数表是所有类对象共享的，每个类对象都会在构造时首先生成一个虚表指针，指向这个虚函数表，然后才是各个成员变量，所以有虚函数的类对象会比没有虚函数的类多一个虚表指针，虚表指针跟其他指针没有区别，在64位系统中就是占用8个字节；
4. 一个派生类非虚继承于一个有虚函数的类，不论派生类是否有同样的虚函数，它的内存布局都只是在有虚函数的基类基础上增加派生类的成员变量，虚表指针是直接继承基类的，指向基类虚表指针，如果派生类有同样的虚函数，那就覆盖基类虚表中同名函数，如果是派生类独有的虚函数，那就追加在基类虚函数表后面；
5. 一个派生类虚继承于一个有虚函数且没有成员变量的基类，则派生类也不会生成它自己的虚表指针和虚函数表，此时内存布局是首先是虚表指针，然后是派生类的成员变量，与第4点区别不大；
6. 一个派生类虚继承于一个有虚函数且有成员变量的基类，此时派生类会重新生成它自己的虚表指针和虚函数表，内存布局则是派生类的虚表指针和成员变量在前，基类的虚表指针和成员变量在后；
7. 多重继承时最好使用虚继承，否则不只是会产生令人头疼的二义性问题，还会多一份虚基类的拷贝，使用虚继承以后，大家共享虚基类，既节约了空间，又避免了二义性问题。



---

### 23  程序内存分配方式以及它们的区别

内存分配大致上可以分成5块：

1. 栈区（stack）。栈，就是那些由编译器在需要时分配，在不需要的时候自动清楚的变量的存储区。里面的变量通常是局部变量、函数参数等。
2. 堆区（heap）。一般由程序员分配、释放，若程序员不释放，程序结束时可能由系统回收。
3. 全局区（静态区）（static）。全局变量和静态变量被分配到同一块内存中。程序结束后由系统释放。
4. 常量存储区。常量字符串就是放在这里的，不允许修改，程序结束后由系统释放。
5. 程序代码区。存放函数体的二进制代码。



---



### 24 static关键字的作用

##### 全局静态变量

在全局变量前加上关键字static，全局变量就被定义成一个全局静态变量。

存放区：存放在静态存储区，在整个程序运行期间一直存在。

初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非它被显式初始化）

作用域：全局静态变量在声明它的文件之外是不可见的，准确来说作用域是从定义之处开始，到文件结尾。

##### 局部静态变量

在局部变量前加上关键字static，局部变量就被定义成一个局部静态变量。

存放区：静态存储区。

初始化：未经初始化的局部静态变量会被自动初始化为0（自动对象的值是任意的，除非它被显示初始化）

作用域：作用域仍然是局部作用域，当定义它的语句块结束时，作用域结束。但是当局部静态变量离开作用域后，并没有被销毁，而是仍然驻留在内存当中，只不过我们不能对其进行访问，除非该函数再次被调用，并且该局部静态变量值不变。

##### 静态函数

在函数返回类型前加static，函数就被定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只在声明它的文件当中可见，不能被其他文件所用。

这个函数只可以被本cpp内使用，不会和其他cpp中的同名函数引起冲突。

**类的静态成员**

在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会被破坏隐藏的原则，也就是保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。

**类的静态函数**

静态成员函数和静态成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名，可以直接使用class_name::static_func()就可以访问。



---

### 25 什么是RAII

RAII 是资源获取即初始化（Resource Acquisition Is Initialization）的缩写，是一种 C++ 的编程技术和设计模式。

RAII 的核心思想是，使用对象的构造函数在对象创建时获取资源，使用对象的析构函数在对象销毁时释放资源。这样可以确保资源在使用完毕后能够被正确释放，避免资源泄漏和内存泄漏的问题。

具体来说，使用 RAII 的方式是将资源的管理交给一个对象来处理，这个对象负责资源的获取和释放。当对象被创建时，资源会被获取；当对象被销毁时，析构函数会被调用，从而自动释放资源。这样可以确保资源的正确释放，无论在任何情况下，包括异常抛出的情况下。

常见的使用 RAII 的场景包括：

1. 动态内存管理：使用智能指针（如 std::shared_ptr、std::unique_ptr）来管理动态分配的内存，确保内存的自动释放。
2. 文件操作：使用文件句柄类来管理文件的打开和关闭，以确保文件资源的正确释放。
3. 锁的管理：使用互斥锁类（如 std::mutex）或其他同步原语的封装，通过构造函数锁定资源，析构函数自动释放锁，确保线程安全。

RAII 能够简化资源管理的代码，提高代码的可读性和可维护性，避免了手动管理资源带来的潜在错误。同时，它也是 C++ 中的一种优秀的异常安全编程方式，能够确保在异常发生时资源能够正确释放。

```c++
#include <iostream>
#include <memory>

template <typename T>
class RAII {
private:
    T* ptr;

public:
    RAII() : ptr(nullptr) {}

    RAII(T* resource) : ptr(resource) {}

    ~RAII() {
        if (ptr) {
            delete ptr;
        }
    }

    T* get() const {
        return ptr;
    }

    void reset(T* resource) {
        if (ptr) {
            delete ptr;
        }
        ptr = resource;
    }

    T& operator*() const {
        return *ptr;
    }

    T* operator->() const {
        return ptr;
    }
};

int main() {
    RAII<int> raii(new int(42));

    std::cout << *raii << std::endl; // 输出：42

    (*raii)++;
    std::cout << *raii << std::endl; // 输出：43

    raii.reset(new int(100));
    std::cout << *raii << std::endl; // 输出：100

    return 0;
}
```



---

### 26 C++ 中的关键字

##### C++11

1. `auto`: 用于自动推导变量的类型。编译器会根据变量的初始化表达式自动推导出变量的类型。
2. `nullptr`: 用于表示空指针，替代了传统的 `NULL`。`nullptr` 具有明确的类型，可以避免因类型不匹配而引发的问题。
3. `decltype`: 用于获取表达式的类型，可以用于定义变量或函数返回类型，避免类型重复定义。
4. `constexpr`: 用于声明常量表达式，可以在编译时求值。被声明为 `constexpr` 的变量或函数可以在编译时进行计算，提高了性能和编译时检查。
5. `static_assert`: 用于在编译时进行断言检查，如果条件不满足，会导致编译错误。可以用于进行静态的类型检查和条件验证。
6. `override`: 用于显式地标记派生类中覆盖基类虚函数的成员函数，以增加代码的可读性和可维护性。
7. `final`: 用于禁止派生类对基类虚函数的进一步覆盖，以增加代码的安全性和可靠性。

8. `default`: 用于声明默认的特殊成员函数。当一个类需要默认的构造函数、析构函数、拷贝构造函数、拷贝赋值运算符或移动构造函数时，可以使用 `default` 关键字显式声明该特殊成员函数为默认的实现。这使得编译器可以自动生成默认的实现，而无需手动编写。
9. `delete`: 用于禁用特殊成员函数或普通成员函数。通过在函数声明中使用 `delete` 关键字可以阻止该函数的使用。这对于防止特定函数的意外调用或禁止某些类型的操作非常有用。



---

### 27 引用和指针的区别

C++引用和指针是两种不同的变量类型，它们有以下区别：

1. 定义和使用方式：指针使用`*`来声明和操作，而引用使用`&`来声明。指针可以为空（nullptr），但引用必须在声明时初始化，并且一旦初始化后不能改变引用的目标。
2. 空值：指针可以为空（null），表示不指向任何对象。引用必须引用一个已经存在的对象，不能为空。
3. 内存分配：指针可以通过`new`运算符动态分配内存，也可以指向栈上的对象。引用只能引用栈上的对象。
4. 重新赋值：指针可以通过改变指向来引用不同的对象，或者将指针设置为空。引用一旦初始化后，不能改变引用的目标。
5. 空间占用：指针通常占用4个或8个字节的空间，根据操作系统的位数和编译器的实现而定。引用不占用额外的空间，它只是目标对象的别名。
6. 空间访问：指针可以访问指向对象的成员，通过解引用操作符`*`和成员访问操作符`.`。引用可以直接通过成员访问操作符`.`访问目标对象的成员。
7. 空间操作：指针可以进行空间操作，如指针运算（加减指针）、比较（大于、小于等）、指针的递增和递减等。引用不能进行空间操作。

总的来说，指针更加灵活，可以为空、可以指向不同的对象，可以进行空间操作；而引用更加简洁，不能为空、不能改变目标对象、不能进行空间操作，但更安全且易于使用。



---



### 28 volatile的作用

volatile是 C 语言中的一个关键字，用于修饰变量，表示该变量的值可能在任何时候被外部因素更改，例如硬件设备、操作系统或其他线程。

当一个变量被声明为volatile时，编译器会禁止对该变量进行优化，以确保每次访问变量时都会从内存中读取其值，而不是从寄存器或缓存中读取。

避免因为编译器优化而导致出现不符合预期的结果



---



### 29 struct和typedef的区别

##### 区别

**语法和实现机制：**

- 宏定义 #define 在编译期间将宏展开，并替换宏定义中的代码。预处理器只进行简单的文本替换，不涉及类型检查。

比如：

```c++
#define INT_VECTOR std::vector<int>
```

- typedef 是一种类型定义关键字，用于为现有类型创建新的名称（别名）。


与宏定义不同，typedef 是在编译阶段处理的，有更严格的类型检查。

```
typedef std::vector<int> IntVector;
```

**作用域限制：**

- 宏定义没有作用域限制，只要在宏定义之后的地方，就可以使用宏。

通常用于定义常量、简单的表达式或简单的代码片段。

- typedef 遵循 C++ 的作用域规则，可以受到命名空间、类等结构的作用域限制。


typedef 通常用于定义复杂类型的别名，使代码更易读和易于维护，如：

```c++
typedef std::map<std::string, std::vector<int>> StringToIntVectorMap;
```

**模板支持：**
宏定义不支持模板，因此不能用于定义模板类型别名。

```c++
// typedef 可以与模板结合使用，但在 C++11 之后，推荐使用 using 关键字定义模板类型别名。

// 使用 typedef 定义模板类型别名
template <typename T>
struct MyContainer {
    typedef std::vector<T> Type;
};

// 使用 using 定义模板类型别名（C++11 及以后）
template <typename T>
struct MyContainer {
    using Type = std::vector<T>;
};
```

