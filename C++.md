### 1 左值、右值及其引用的区别

##### 概念

###### **左值**

- 左值既可以出现在等号左边，也能出现在等号右边
- 左值可以修改
- 左值是可寻址的变量，具有持久性

###### **纯右值**

- 右值只能出现在等号右边

- 右值不可修改
- 右值一般是不可寻址的常量，具有临时性

###### **将亡值**

- C++11新增的与右值引用相关的表达式
- 常用来完成移动构造或移动赋值的特殊任务，扮演着“将亡”的角色

- 将亡值定义了这样一种行为：具名的临时值、同时又能够被move。



##### 示例

###### **左值示例**

- 变量名、函数名以及数据成员名
- 返回左值引用的函数调用
- 由赋值运算符或复合赋值运算符连接的表达式，如(a=b, a-=b等)
- 解引用表达式*ptr
- 前置自增和自减表达式(++a, ++b)
- 成员访问（点）运算符的结果
- 由指针访问成员（ `->` ）运算符的结果
- 下标运算符的结果(`[]`)
- 字符串字面值("abc")

###### **纯右值示例**

- 字面值(字符串字面值除外)，例如1，'a', true等
- 返回值为非引用的函数调用或操作符重载，例如：str.substr(1, 2), str1 + str2, or it++
- 后置自增和自减表达式(a++, a--)
- 算术表达式
- 逻辑表达式
- 比较表达式
- lambda表达式

###### **将亡值示例**

- 返回右值引用的函数返回值，如static_cast<T&&>(t)

- 转换为右值引用的转换函数的返回值，如std::move(t)



##### 引用

###### **左值引用**

- 只能引用左值
- 通过&运算符声明

###### **右值引用**

- 只能引用右值

- 通过&&运算符声明



> **C++11的右值引用：**
>
> - 右值引用具有移动语义，可以通过std::move函数将资源的所有权（如动态分配的内存）从一个对象转移到另一个对象，避免了不必要的拷贝和内存分配。
> - 右值引用还使得实现“完美转发”成为可能，也就是将传入的参数原样传递给其他函数，避免了多次拷贝。





##### 文心一言版解释

> 左值引用和右值引用是C++中两种重要的概念，它们的区别和意义如下：
>
> 1. 左值引用和右值引用的区别：
>    - 基本概念：左值是可以放在赋值号左边，可以被赋值的值，它必须有内存实体；而右值是当在赋值号右边取出值赋给其他变量的值，它可以在内存也可以在CPU寄存器。
>    - 操作方式：左值引用是用来改变指针的指向，还可以改变指针所指向的值；右值引用可以用来给左值赋值。
> 2. 右值引用的意义：
>    - 提高效率：通过避免不必要的对象拷贝，节省运算存储资源，提高程序的执行效率。
>    - 简化操作：使得泛型编程更为简洁明确，便于操作。



##### ChatGPT版解释

> 1. 区别：
>
> - 左值引用（lvalue reference）：通过&符号来声明，只能引用左值（具有内存地址的表达式或变量），可以修改左值。
> - 右值引用（rvalue reference）：通过&&符号来声明，只能引用右值（临时或即将销毁的值），可以修改右值。
>
> 2. 右值引用的意义：
>
> - 资源移动：右值引用可以通过std::move函数，将一个对象的资源所有权从一个对象转移到另一个对象，避免了不必要的内存拷贝和分配。
> - 完美转发：右值引用允许我们实现所谓的“完美转发”，即将传入的参数原样传递给其他函数，避免了多次拷贝。
> - 优化性能：右值引用可以避免不必要的对象拷贝和析构，提高程序的性能和效率。



参考文章：

[深入理解左值和右值 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/513628368)





---



### 2 C++内存泄漏

##### 概念

内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。



##### 分类

内存泄漏分为以下两类：

- **堆内存泄漏**：我们经常说的内存泄漏就是堆内存泄漏，在堆上申请了资源，在结束使用的时候，没有释放归还给OS，从而导致该块内存永远不会被再次使用
- **资源泄漏**：通常指的是系统资源，比如socket，文件描述符等，因为这些在系统中都是有限制的，如果创建了而不归还，久而久之，就会耗尽资源，导致其他程序不可用

##### 根源

- **进程内存布局**

![image-20231010160523235](C:\Users\WangZhe\AppData\Roaming\Typora\typora-user-images\image-20231010160523235.png)

​	上图为32位进程的内存布局，从上图中主要包含以下几个块：

​	[内核空间](https://www.zhihu.com/search?q=内核空间&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})：供内核使用，存放的是内核代码和数据

​	stack：这就是我们经常所说的栈，用来存储[自动变量](https://www.zhihu.com/search?q=自动变量&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})([automatic variable](https://www.zhihu.com/search?q=automatic variable&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260}))

​	mmap:也成为[内存映射](https://www.zhihu.com/search?q=内存映射&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})，用来在进程[虚拟内存](https://www.zhihu.com/search?q=虚拟内存&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})地址空间中分配地址空间，创建和[物理内存](https://www.zhihu.com/search?q=物理内存&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})的映射关系

​	heap:就是我们常说的堆，动态内存的分配都是在堆上

​	bss:包含所有未初始化的全局和[静态变量](https://www.zhihu.com/search?q=静态变量&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})，此段中的所有变量都由0或者空[指针初始化](https://www.zhihu.com/search?q=指针初始化&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})，程序加载器在加载程序时为BSS段分配内存

​	data:初始化的数据块

- - 包含显式初始化的[全局变量](https://www.zhihu.com/search?q=全局变量&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})和静态变量

  - 此段的大小由[程序源代码](https://www.zhihu.com/search?q=程序源代码&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})中值的大小决定，在运行时不会更改

  - 它具有读写权限，因此可以在运行时更改此段的变量值

  - 该段可进一步分为[初始化只读区](https://www.zhihu.com/search?q=初始化只读区&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})和初始化读写区


​	text：也称为文本段

- - 该段包含已编译程序的[二进制文件](https://www.zhihu.com/search?q=二进制文件&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})。
  - 该段是一个只读段，用于防止程序被意外修改
  - 该段是可共享的，因此对于[文本编辑器](https://www.zhihu.com/search?q=文本编辑器&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})等频繁执行的程序，内存中只需要一个副本

- **内存分配**

  - **静态分配**

    编译时分配。包括:全局、静态全局、静态局部三种变量。

  - **动态分配**

    堆上通过malloc函数进行内存的动态分配，通过malloc（new）函数分配的内存需要开发人员通过free（delete）函数手动释放，因此容易发生内存泄漏

    栈上通过alloca函数进行内存的动态分配，通过alloca函数分配的内存由编译器进行释放，无需手动操作


- **堆和栈的区别**

​	**空间大小不同**

​	一般来讲在 32 位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。

​	对于栈来讲，一般都是有一定的空间大小的，一般依赖于操作系统(也可以人工设置)

​	**能否产生碎片不同**

​	对于堆来讲，频繁的内存分配和释放势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。

​	对于栈来讲，内存都是连续的，申请和释放都是指令移动，类似于[数据结构](https://www.zhihu.com/search?q=数据结构&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})中的进栈和出栈

​	**增长方向不同**

​	对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向

​	对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长

​	**分配方式不同**

​	堆都是动态分配的，比如我们常见的malloc/new；而栈则有静态分配和动态分配两种。

​	静态分配是编译器完成的，比如局部变量的分配，而栈的动态分配则通过alloca()函数完成

​	二者动态分配是不同的，栈的动态分配的内存由编译器进行释放，而堆上的动态分配的内存则必须由开发人自行释放

​	**分配效率不同**

​	栈有操作系统分配专门的[寄存器](https://www.zhihu.com/search?q=寄存器&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高

​	堆内存的申请和释放专门有运行时库提供的函数，里面涉及复杂的逻辑，申请和释放效率低于栈



##### 内存泄漏产生方式

- 常发性内存泄漏

​	产生内存泄漏的代码或者函数会被多次执行到，在每次执行的时候，都会产生内存泄漏

- 偶发性内存泄漏

​	偶发性内存泄漏函数只在特定的场景下才会被执行。

- 一次性内存泄漏

​	偶发性内存泄漏函数只在特定的场景下才会被执行。

- 隐式内存泄漏

​	程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。



##### 内存泄漏产生原因

- **未释放**

如下代码所示，申请内存后，没有调用free函数进行释放，造成内存泄漏

```C
int fun() {
    char * pBuffer = malloc(sizeof(char));
    
    /* Do some work */
    return 0;
}
```

或者是下面代码中，析构函数没有释放掉为成员变量申请的动态内存

```C
class Obj {
 public:
   Obj(int size) {
     buffer_ = new char;
   }
   ~Obj(){}
  private:
   char *buffer_;
};

int fun() {
  Object obj;
  // do sth
  return 0;
}
```

- **未匹配**

  - new和free

  ```C
  Test *t = new Test;
  free(t)
  ```

  此处会产生内存泄漏。new操作符会先通过operator new分配一块内存，然后在该块内存上调用placement new即调用Test的构造函数。而在上述代码中，只是通过free函数释放了内存，但是没有调用Test的析构函数以释放Test的成员变量，从而引起内存泄漏。

  - new[]和delete

  ```C
  int main() {
    Test *t = new Test [10];
    // do sth
    delete t;
    return 0;
  }
  ```

  在上述代码中，我们通过new创建了一个Test类型的数组，然后通delete操作符删除该数组，编译并执行，输出如下：

  ```C
  in Test
  in Test
  in Test
  in Test
  in Test
  in Test
  in Test
  in Test
  in Test
  in Test
  in ~Test
  ```

  从上面输出结果可以看出，调用了10次构造函数，但是只调用了一次析构函数，所以引起了内存泄漏。这是因为调用delete t释放了通过operator new[]申请的内存，即malloc申请的内存块，且只调用了t[0]对象的析构函数，t[1..9]对象的析构函数并没有被调用。

- **虚析构**

在C++中，虚析构函数是一种特殊的析构函数，用于在派生类对象被删除时正确释放资源。当基类指针指向派生类对象并删除该指针时，如果基类的析构函数不是虚构函数，那么只会调用基类的析构函数，而不会调用派生类的析构函数，这可能导致派生类特有的资源无法正确释放，造成内存泄漏。

为了解决这个问题，可以将基类的析构函数声明为虚析构函数，即在基类的析构函数前加上关键字"virtual"。这样，当基类指针指向派生类对象并删除该指针时，会先调用派生类的析构函数，然后再调用基类的析构函数，从而正确释放派生类特有的资源。

虚析构函数的一般语法如下：

```cpp
class Base {
public:
    virtual ~Base() {
        // 基类析构函数的实现
    }
};

class Derived : public Base {
public:
    ~Derived() override {
        // 派生类析构函数的实现
    }
};
```

> 需要注意的是，派生类的析构函数可以选择是否加上"override"关键字，但建议加上以提高代码的可读性和可维护性。同时，由于虚析构函数会增加额外的开销，只有在需要通过基类指针删除派生类对象时才需要使用虚析构函数。

**存在继承关系的情况下，构造函数和析构函数的调用顺序**

​	派生类对象在创建时构造函数调用顺序：

1. 调用父类的构造函数
2. 调用父类成员变量的构造函数
3. 调用派生类本身的构造函数

​	派生类对象在析构时的析构函数调用顺序：

1. 执行派生类自身的析构函数
2. 执行派生类成员变量的析构函数
3. 执行父类的析构函数



- **循环引用**

​		循环引用问题在C++中是指当两个或多个对象互相持有对方的引用（通常是通过[智能指针](https://so.csdn.net/so/search?q=智能指针&spm=1001.2101.3001.7020)），导致它们的引用计数永远不会降为零，从而导致内存泄漏的情况。这种问题在使用`shared_ptr`时尤为突出，因为`shared_ptr`会自动管理对象的生命周期并维护引用计数。

​		比如：

```C
class A {
public:
    std::shared_ptr<B> b_ptr;
};
 
class B {
public:
    std::shared_ptr<A> a_ptr;
};
```

​		当创建A,B对象时，并使他们相互引用

```C
std::shared_ptr<A> a = std::make_shared<A>();
std::shared_ptr<B> b = std::make_shared<B>();
a->b_ptr = b;
b->a_ptr = a;
```

​		在这个例子中，A对象持有B对象的`shared_ptr`，B对象持有A对象的`shared_ptr`。这会导致循环引用，因为A和B的引用计数都为1，它们都不会被自动销毁。这种情况下，即使`shared_ptr`超出其作用域，相关对象也不会被释放，从而导致[内存泄漏](https://so.csdn.net/so/search?q=内存泄漏&spm=1001.2101.3001.7020)。

为了解决循环引用问题，我们可以将B类中的`shared_ptr<A>`替换为`weak_ptr<A>`，这样就可以打破循环引用：

```C
class B {
public:
    std::weak_ptr<A> a_ptr;
};
```

> 需要注意的是，`weak_ptr`无法直接访问其指向的对象。要访问对象，必须先将`weak_ptr`转换为`shared_ptr`，这可以通过`lock()`成员函数实现。同时，在访问之前，可以使用`expired()`成员函数检查`weak_ptr`是否悬空，以确保安全访问。

##### 如何避免内存泄漏

- **避免在堆上分配**

​		大部分的内存泄漏都是在堆上分配引起的，但如果实际应用场景中可以不用到堆，比如对象可以在栈上分配，一方面栈的效率高于堆，另一方面，还能避免内存泄漏。

- **手动释放**
  - 对于[malloc函数](https://www.zhihu.com/search?q=malloc函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260})分配的内存，在结束使用的时候，使用free函数进行释放
  - 对于new操作符创建的对象，切记使用delete来进行释放
  - 对于new []创建的对象，使用delete[]来进行释放(使用free或者delete均会造成内存泄漏)
- **避免使用裸指针**
- **使用STL库**

​	如std::vector或std::array代替C语言数组，使用std::string代替char*等

- **智能指针**

  - unique_ptr

    unique_ptr是限制最严格的一种智能指针，用来替代之前的auto_ptr，独享被管理对象指针所有权。当unique_ptr对象被销毁时，会在其析构函数内删除关联的原始指针。

  - shared_ptr

    shared_ptr是共享管理权，即多个shared_ptr可以共用同一块关联对象，其内部采用的是引用计数，在拷贝的时候，引用计数+1，而在某个对象退出作用域或者释放的时候，引用计数-1，当引用计数为0的时候，会自动释放其管理的对象。

  - weak_ptr

    weak_ptr是智能指针中最弱的一个，weak_ptr只能访问所指向的内存区域，当weak_ptr生命周期结束的时候，其所指向的内存依旧完好无损。weak_ptr主要与shared_ptr一起使用。

    > 引用计数指针的本质是”在内存需要析构时，引用及技术指针的计数值不断的减1直到为0，从而对内存进行析构“，但是weak_ptr不会影响shared_ptr引用计数指针的计数值，即weak_ptr不会影响到只想去与内存的生命周期
    >
    > 因此这也就是weak_ptr不会导致无限循环释放的错误；

- **RAII**

​	RAII是Resource Acquisition is Initialization(资源获取即初始化)的缩写，是C++语言的一种管理资源，避免泄漏的用法。

​	利用的就是C++构造的对象最终会被销毁的原则。利用C++对象生命周期的概念来控制程序的资源,比如内存,[文件句柄](https://www.zhihu.com/search?q=文件句柄&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2973245260}),网络连接等。

​	RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命周期内控制对资源的访问，使之始终保持有效，最后在对象析构	的时候，释放构造时获取的资源。

​	简单地说，就是把资源的使用限制在对象的生命周期之中，自动释放。



##### 如何定位内存泄漏

- 日志

​		这种方案的核心思想，就是在每次分配内存的时候，打印指针地址，在释放内存的时候，打印内存地址，这样在程序结束的时候，通过分配和释放的差，如果分配的条数大于释放的条数，那么基本就能确定程序存在内存泄漏，然后根据日志进行详细分析和定位。

```C
char * fun() {
  char *p = (char*)malloc(20);
  printf("%s, %d, address is: %p", __FILE__, __LINE__, p);
  // do sth
  return p;
}

int main() {
  fun();
  
  return 0;
}
```

- **统计**

​	统计方案可以理解为日志方案的一种特殊实现，其主要原理是在分配的时候，统计分配次数，在释放的时候，则是统计释放的次数，这样在程序结束前判断这俩值是否一致，就能判断出是否存在内存泄漏。

​	此方法可帮助跟踪已分配内存的状态。为了实现这个方案，需要创建三个自定义函数，一个用于内存分配，第二个用于内存释放，最后一个用于检查内存泄漏。

- **工具**

  - valgrind

  - mtrace

  - dmalloc

  - ccmalloc

  - memwatch

  - debug_new

##### 参考文章

[C++ 怎么检测内存泄露，怎么定位内存泄露？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/63946754/answer/2973245260)

[深入理解C++中的循环引用问题及解决方法_c++循环引用_adam2021的博客-CSDN博客](https://blog.csdn.net/adam2021/article/details/129849022)



---

###  3 const char *p 、 char const *p 与 char * const p的区别

const修饰的位置不同，会对指针p的性质产生不同的影响。

##### const char *p

指针p指向的是一个常量字符，即p所指向的字符内容不能通过指针p来修改，但是指针p可以指向其他的字符。

例如：

```C++
const char *p = "Hello"; // p指向一个字符串常量，不能通过p修改字符内容
```

p = "World"; // 可以将p指向"World"

##### char const *p

与const char *p相同，指针p也指向的是一个常量字符，即p所指向的字符内容不能通过指针p来修改，但是指针p可以指向其他的字符。

##### char * const p

指针p本身是一个常量指针，即p的值不能改变，它始终指向一个固定的地址，但是该地址中的字符内容可以通过指针p进行修改。

例如：

```c++
char str1[] = "Hello";
char * const p = str1; // p是一个常量指针，始终指向str1的地址
p[0] = 'h'; // 可以通过p来修改str1的字符内容
char str2[] = "World";
//p = str2; // 不能修改指针p的值，会报错
```



> 总结：const char *p 和 char const *p 是等价的，指针p指向的是一个常量字符；而char * const p是一个常量指针，指针p自身的值不能改变，但是可以通过指针p来修改字符内容。





---



### 4 static_cast、dynamic_cast、reinterpret_cast 和 const_cast的区别

##### static_cast

用于基本类型之间的强制类型转换，以及具有继承关系的指针或引用之间的转换。它在**编译时**进行类型检查，不会进行dynamic_cast所需的运行时类型检查。

##### dynamic_cast

用于具有继承关系的指针或引用之间的转换，可以在**运行时**检查对象的类型是否能够转换成功。它只能用于具有虚函数的类（即多态类型），可以在将多态类型的指针或引用转换为其派生类指针或引用时使用。如果转换是不安全的，dynamic_cast返回一个空指针（对指针）或抛出一个std::bad_cast异常（对引用）。

dynamic_cast的底层原理依赖于运行时类型信息（RTTI, Runtime Type Information）。

C++编译器在编译时为支持多态的类生成RTTI，它包含了类的类型信息和类层次结构。

**工作原理的简化描述：**

- 首先，dynamic_cast通过查询对象的 vptr 来获取其RTTI（这也是为什么 dynamic_cast 要求对象有虚函数）

- 然后，dynamic_cast比较请求的目标类型与从RTTI获得的实际类型。如果目标类型是实际类型或其基类，则转换成功。
- 如果目标类型是派生类，dynamic_cast会检查类层次结构，以确定转换是否合法。如果在类层次结构中找到了目标类型，则转换成功；否则，转换失败。
- 当转换成功时，dynamic_cast返回转换后的指针或引用。
- 如果转换失败，对于指针类型，dynamic_cast返回空指针；对于引用类型，它会抛出一个std::bad_cast异常。



##### reinterpret_cast

用于不同类型的指针、引用或任意类型之间的转换，它提供了一种底层的重新解释目标类型的方法，但是很容易导致未定义行为。reinterpret_cast不会进行任何类型检查，因此需要谨慎使用。

##### const_cast

用于添加或移除const、volatile修饰符，通常用于去除const限定，使一个const对象变为非常量。const_cast只能操作指针或引用，不能用于按值的变量。需要注意的是，const_cast只能改变底层对象的const性质，不能用于改变底层对象类型。



---



### 5 C++静态多态和动态多态

C++中的多态是指同一函数可以根据调用的对象的实际类型来执行不同的操作。多态通过基类指针或引用调用派生类对象的成员函数，实现对不同类型的对象的统一操作。

C++中的多态有两种实现方式：编译时多态（静态多态）和运行时多态（动态多态）。

1. 编译时多态（静态多态）：
   - 函数重载：在同一作用域内，相同函数名但参数列表不同的函数可以有多个版本，编译器根据实参的类型来决定调用哪个函数。
   - 模板：使用通用的算法实现，根据实际参数的类型在编译时将相应的代码生成。
2. 运行时多态（动态多态）：
   - 虚函数（虚函数重写）：使用基类的指针或引用调用派生类的重写函数，实际调用的是派生类中与基类虚函数同名的函数。通过将基类的函数声明为虚函数，在运行时确定调用的是哪个类的函数，实现多态性。
   - 动态绑定：使用基类指针或引用调用派生类对象的函数时，会在运行时动态绑定到正确的成员函数上，实现函数的动态调用。



---



### 6 enable_shared_from_this是什么

##### 概述

`enable_shared_from_this` 是 C++ 标准库提供的一个模板类，位于 `<memory>` 头文件中。它用于解决由于对象被 `shared_ptr` 管理内存导致的问题，即在对象中获取自身的 `shared_ptr`。

当某个类继承自 `enable_shared_from_this` 时，该类的对象可以通过调用`shared_from_this()`函数来获取一个指向自己的 `shared_ptr`。这样，在对象被 `shared_ptr` 管理时，可以避免手动创建一个新的 `shared_ptr` 导致的内存泄漏或对象的多个 `shared_ptr` 不一致的问题。

使用 `enable_shared_from_this` 的关键是避免直接通过构造函数创建一个 `shared_ptr`，而是通过类内部的成员函数获取指向自身的 `shared_ptr`。这样可以确保 `shared_ptr` 的计数器被正确维护，避免多个 `shared_ptr` 对同一个对象进行资源管理而导致的问题。

使用 `enable_shared_from_this` 可以更方便地在对象中获取到指向自身的 `shared_ptr`，避免手动管理对象的生命周期，提高代码	的可维护性和安全性。

##### 使用条件

1. 对象必须是由 `shared_ptr` 管理的，不能使用 `unique_ptr` 或者原始指针。
2. 在对象中不能直接或间接创建一个新的 `shared_ptr`，否则会引发 `std::bad_weak_ptr` 异常。
3. 调用 `shared_from_this()` 时，必须保证对象已经被至少一个 `shared_ptr` 管理，否则会导致 `std::bad_weak_ptr` 异常的发生。



##### 使用步骤

要使用 `enable_shared_from_this`，需要遵循以下步骤：

1. 定义一个类，并使其继承自 `std::enable_shared_from_this`：

```c++
class MyClass : public std::enable_shared_from_this<MyClass> {
  // 类的成员和方法
};
```

2. 在需要获取指向自身的 `shared_ptr` 的地方，调用 `shared_from_this()` 方法：

```c++
std::shared_ptr<MyClass> obj = std::make_shared<MyClass>();
std::shared_ptr<MyClass> sharedPtr = obj->shared_from_this();
```



---

### 7 常量指针和指针常量的区别

1. 常量指针（Const Pointer）：
   常量指针是指向常量的指针。它不能改变所指向的值，但可以改变指针本身的值，也就是让它指向其他的内存地址。例如：

```cpp
const int *p = &a; // p指向a，不能通过p改变a的值，但可以改变p指向的其他变量
```

这意味着，你可以改变指针 `p` 所指向的地址，但不能通过 `p` 来改变它所指向的变量的值。

2. 指针常量（Pointer Constant）：
   指针常量是指针本身是常量，即指针不能改变，而指针所指向的值可以改变。例如：

```cpp
int * const p = &a; // p是一个常量指针，不能改变p的值，但可以改变p所指向的变量的值
```

这意味着，你不能改变指针 `p` 的地址（即不能让 `p` 指向其他的变量），但可以通过 `p` 来改变它所指向的变量的值。

总结一下，"常量指针"是一个指向常量的指针，它不能通过这个指针来改变所指向的变量的值；而"指针常量"则是一个指针本身是常量，即它不能指向其他的变量，但可以通过这个指针来改变它所指向的变量的值。



---



### 8 为什么auto_ptr会被弃用

`auto_ptr` 在 C++98 标准中是一个常用的智能指针类型，它可以在超出作用域时自动删除它所拥有的对象。然而，它在 C++11 中被弃用，并在 C++17 中被移除，主要有以下几个原因：

1. **所有权问题**：`auto_ptr` 的一个主要问题是它不能很好地支持STL容器。当多个 `auto_ptr` 指向同一个对象时，删除其中一个并不会删除其他 `auto_ptr` 所指向的对象，这导致了内存泄漏。这是因为在 C++98 中，`auto_ptr` 并不支持所有权的概念。
2. **不适用于数组**：`auto_ptr` 在处理动态分配的数组时也有问题。当 `auto_ptr` 被删除时，它只会删除第一个元素，而不会删除整个数组，这可能导致内存泄漏。
3. **不适用于自定义类型**：`auto_ptr` 在处理自定义类型时可能会出现问题。如果一个类型的析构函数抛出一个异常，那么 `auto_ptr` 会删除它所指向的对象，然后再删除一次，这可能导致未定义的行为。
4. **所有权转移**：`auto_ptr` 不支持所有权转移。这意味着你不能把一个 `auto_ptr` 的所有权从一个变量转移到另一个变量。这限制了 `auto_ptr` 的使用场景。

为了解决上述问题，C++11引入了新的智能指针类型 `std::unique_ptr` 和 `std::shared_ptr`。这两个类型可以更好地管理动态分配的内存，支持所有权的概念，并且可以很好地与 STL 容器集成。因此，`auto_ptr` 被弃用并最终从标准库中移除也就理所当然了



---



### 9 new/delete与malloc/free的区别

`new` 和 `delete` 是 C++ 中用于动态分配和释放对象的运算符，而 `malloc` 和 `free` 是 C 语言中用于动态分配和释放内存的函数。它们之间存在以下几个区别：

**类型安全性**：`new` 和 `delete` 是类型安全的，它们会根据类型进行内存分配和释放，并在分配对象时调用构造函数，在释放对象时调用析构函数。而 `malloc` 和 `free` 是无类型的，它们只是在字节级别进行内存分配和释放，不会调用构造函数和析构函数。

**内存分配大小**：`new` 运算符根据指定的类型自动计算所需的内存大小，而 `malloc` 函数需要手动指定所需的字节数。例如，`new int` 分配一个 `int` 大小的内存，而 `malloc(sizeof(int))` 需要手动指定所需的字节数。

**异常处理**：`new` 运算符在分配内存失败时，会抛出 `std::bad_alloc` 异常，以便于异常处理。而 `malloc` 函数在分配内存失败时，返回 `NULL`。

**自定义类型支持**：`new` 可以分配自定义类型的内存，并在分配时调用构造函数。而 `malloc` 只能分配字节大小的内存块。

**是否调用构造函数/析构函数**
使用new操作符来分配对象内存时会经历三个步骤：

- 第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。

- 第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。
- 第三部：对象构造完成后，返回一个指向该对象的指针。

使用delete操作符来释放对象内存时会经历两个步骤：

- 第一步：调用对象的析构函数。

- 第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。



总之，`new` 和 `delete` 是 C++ 中的运算符，提供了更高级、类型安全和自动处理的内存分配和释放机制。而 `malloc` 和 `free` 则是 C 语言中的函数，更为底层、无类型且手动指定内存字节数。建议在 C++ 中优先使用 `new` 和 `delete`，除非有特定的兼容性或其他原因需要使用 `malloc` 和 `free`。



---



### 10 内联函数是怎么实现的，有什么优缺点

##### 概念

内联函数是一种编译器优化技术，用于将函数的代码直接插入到函数调用的地方，而不是通过函数调用的方式进行执行。

##### 实现

内联函数的实现方式主要包括以下两个步骤：

1. 内联声明：在函数声明前加上 `inline` 关键字，告诉编译器将该函数作为内联函数进行处理。内联声明通常放在头文件中，以便在需要时在多个编译单元间共享。
2. 内联展开：编译器在编译过程中遇到内联函数的调用时，将函数的定义直接插入到调用处，替代函数调用的过程。这样，函数的执行就不再通过跳转到函数体的方式，而是直接在调用地点展开执行。

##### 优点

1. 减少函数调用开销：内联函数的内部代码直接嵌入到调用处，避免了函数调用的开销，如栈帧的创建与销毁、参数传递和跳转。
2. 提高代码执行速度：由于内联函数的代码直接展开，消除了函数调用时的跳转和返回过程，可以减少指令跳转带来的延迟，从而提高代码的执行速度。
3. 可以进行更多的编译器优化：内联函数在展开时，编译器能够对其进行更多的优化，如常量折叠、循环展开、无用代码消除等。

##### 缺点

1. 增大代码体积：由于内联函数在调用处展开，会增加代码的重复性，导致可执行文件的体积增大。
2. 增加编译时间：内联函数在每个调用处都需要重新展开，会增加编译时间，尤其是对于大型项目。
3. 可能导致缓存失效：代码展开可能导致指令和数据的增加，使得缓存命中率下降，影响代码的执行效率。

> 在实际使用中，适合内联的函数通常是短小且频繁调用的函数。



---

### 11 this指针

在C++中，`this` 是一个指向当前对象的指针。它是每个非静态成员函数（包括成员函数、成员方法和成员重载运算符）的一个隐式参数，用于指向调用该函数的对象本身。

`this` 指针的作用是允许在类的成员函数中访问和操作当前对象的成员变量和成员函数。通过 `this` 指针，可以区分对象的成员和同名的局部变量或参数，避免命名冲突。

当调用一个对象的成员函数时，编译器会自动将对象的地址传递给 `this` 指针。通过 `this` 指针，可以访问对象的成员变量和成员函数，如 `this->member`（`(*this).member`） 或 `this->method()`。

以下是 `this` 指针的一些特点和使用注意事项：

1. `this` 指针是指向当前对象的常量指针，不允许修改其值。因此，不能将 `this` 指针赋值给其他指针变量。
2. `this` 指针只能在非静态成员函数中使用，静态成员函数没有 `this` 指针。
3. `this` 指针可以在成员函数中进行显式引用，也可以省略不写，编译器会自动添加。
4. `this` 指针可以作为隐式参数传递给其他函数，以便在其他函数中访问当前对象。

使用 `this` 指针可以在类的成员函数中方便地访问和操作对象的成员，特别是在处理成员变量和成员函数名称冲突时非常有用。

> 在C++中，`this` 是一个指向当前对象的指针，它是一个**右值**（rvalue）。
>
> 由于 `this` 是一个右值，因此不能对它进行赋值或修改。它只能用于访问成员



---

### 12 深拷贝和浅拷贝

深拷贝（Deep Copy）和浅拷贝（Shallow Copy）是在C++中用于复制对象或数据的两种不同方式。

1. **浅拷贝：**
   浅拷贝是一种简单的复制操作，它只复制数据成员本身，而不复制指向的数据或对象。即使在复制后，原对象和副本对象仍然共享相同的资源。在浅拷贝中，默认情况下，编译器会提供默认的拷贝构造函数和赋值运算符重载函数，它们会逐个复制数据成员的值。
2. **深拷贝：**
   深拷贝是一种复制操作，它会复制所有的数据成员，包括指向的数据或对象。深拷贝创建了一个新的对象，并为新对象的指针成员分配独立的内存。在深拷贝中，开发者需要自定义拷贝构造函数和赋值运算符重载函数，以确保所有指针成员都进行独立的内存分配和复制。

深拷贝的优势在于它创建了完全独立的拷贝，并且避免了多个对象之间共享资源的问题。每个对象都有自己的独立拷贝，修改一个对象不会影响其他对象

---

### 13 虚函数及其工作机制

虚函数是C++中的一种特殊函数，被声明为虚函数后，它可以在派生类中被重写（override）以实现运行时多态性。虚函数通过运行时动态绑定的机制，使得程序能够根据对象的实际类型来调用相应的函数。

虚函数的工作机制如下：

1. 定义及声明：在基类中，我们可以通过在函数的声明前面加上 `virtual` 关键字来将其声明为虚函数。例如：

```c++
class Base {
public:
    virtual void function(); // 声明为虚函数
};
```

2. 虚函数表：每个有虚函数的类都会维护一个虚函数表（vtable），该表是一个特殊的查找表，存储了虚函数的地址。每个对象（实例）都具有一个指向该虚函数表的隐藏指针（通常称为虚表指针 vptr）。

3. 动态绑定：当调用一个虚函数时，实际调用的是对象的运行时类型所对应的函数。编译器将根据对象的 vptr，从其所属类的虚函数表中找到对应的函数地址，确保调用的是正确的函数版本。

4. 多态性：由于基类指针或引用可以指向派生类对象，通过使用虚函数，我们可以通过基类指针或引用调用相应的派生类函数。而实际调用的函数（派生类中的重写函数）是根据对象的实际类型决定的。这就实现了多态性，即相同的函数调用可以在不同的派生类对象中产生不同的行为。



---

### 14 strlen,sizeof,lengh,size的区别

`strlen`、`sizeof`、`length`、`size` 是 C++ 中常用的用于获取字符串或数据大小的函数或运算符。

1. strlen：`strlen` 是 C 语言中的函数，用于获取以 null 终止的字符串的长度（不包括 null 终止符）。它在 `<cstring>` 头文件中定义。例如，`strlen("Hello")` 将返回 5。
2. sizeof：`sizeof` 是 C++ 中的运算符，用于获取数据类型或变量的字节大小。它返回编译时计算出的值，不需要实际执行代码。例如，`sizeof(int)` 返回整型 `int` 的字节大小。`sizeof` 运算符可以用于任何数据类型、变量或表达式。
3. length：`length` 是 C++ 的字符串类（如 `std::string`）的成员函数，用于获取字符串的长度。它返回字符串的字符数量。例如，`std::string str = "Hello";` 可以使用 `str.length()` 获取字符串的长度。
4. size：`size` 是 C++ 的容器类（如 `std::vector`、`std::array`）的成员函数，用于获取容器中元素的数量。它返回容器的实际大小。例如，`std::vector<int> vec = {1, 2, 3};` 可以使用 `vec.size()` 获取容器中元素的数量。

**总结：**

- `strlen` 用于获取 null 终止的字符串的长度。
- `sizeof` 用于获取数据类型或变量的字节大小。
- `length` 是字符串类的成员函数，用于获取字符串的长度。
- `size` 是容器类的成员函数，用于获取容器中元素的数量。



---



### 15 C++的源代码是如何编译成可执行文件的，说出详细的编译过程

C++源代码编译成可执行文件的过程可以分为预处理、编译、汇编和链接四个阶段：

- **预处理阶段**：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。

- **编译阶段**：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件

- **汇编阶段**：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件

- **链接阶段**：将多个目标文件及所需要的库连接成最终的可执行目标文件

  

---

### 16 C++中如何定义一个只能在堆或只在栈上创建对象的类



- **只在堆上创建对象**

在C++中，类的创建分为两种。一种是静态创建，即直接创建对象，如T *t；另一种是动态创建对象，即通过 new 创建，如 T *t = new T。要想正确回答上题，就必须知道这两种创建方式的区别。

1. **静态创建**

​	由编译器在栈中为对象分配内存，通过移动栈顶指针获得合适大小的空间，然后**调用对象的构造函数**生成对象。

2. **动态创建**

​	通过new在堆中创建对象。这个过程分为两步：首先在堆中找到合适大小的空间并分配，然后**调用对象的构造函数**生成对象。

所以通过将构造函数私有化的做法是行不通的。

> **静态创建的特点**
>
> 编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。

所以只需要将**析构函数私有化**就可以组织直接创建对象了。由于栈的创建和释放都需要由系统完成的，所以若是无法调用构造或者析构函数，自然会报错。

```c++
#include<iostream>
using namespace std;
class test
{
private:
	~test(){ cout << "test destroy" << endl; }
public:
	void destroy()
	{
		delete this;
	}
};
int main()
{
	//test p;//编译器报错test::~test()不可访问
	test *p = new test;
	p->destroy();
}
```

- **只在栈上创建对象**

将 **new操作符重载并设置为私有访问**即可

```c++
#include<iostream>
using namespace std;
class test
{
private:
	void* operator new(size_t t){}
	void operator delete(void* ptr){}
public:
	~test()
	{
		cout << "test destroy" << endl;
	}
};
int main()
{
	//test *A = new test;
	//编译器报错函数test::operator new 不可访问
	test A;
}
```



---



### 17 explicit关键字的作用

`explicit` 关键字在 C++ 中用于修饰**单参数构造函数**（构造函数只接受一个参数），其作用是防止编译器在某些隐式类型转换的情况下自动调用该构造函数。

> 因为无参构造函数和多参构造函数本身就是显示调用的，加上 explicit 关键字也没意义。

具体来说，当类的构造函数被声明为 `explicit` 时，在使用该构造函数进行对象初始化时，必须使用显式的构造函数调用语法，而不是隐式的转换。这样可以避免意外的类型转换，提高代码的可读性和安全性。

下面是一个使用 `explicit` 关键字的示例：

```c++
class MyClass {
public:
    explicit MyClass(int value) {
        // 构造函数的实现
    }
};

void foo(MyClass obj) {
  // 函数的实现
}

int main() {
    MyClass obj1(10); // 通过显式构造函数调用进行对象初始化
    MyClass obj2 = 20; // 错误！禁止隐式类型转换
    foo(30); // 错误！禁止隐式类型转换

    return 0;
}
```

在上述示例中，构造函数 `MyClass(int value)` 声明为 `explicit`，因此在对象初始化时必须使用显式构造函数调用语法，如 `MyClass obj1(10)`。而尝试使用隐式类型转换，如 `MyClass obj2 = 20` 或 `foo(30)`，都会导致编译错误。

通过使用 `explicit` 关键字，可以显式地指定需要进行类型转换的地方，避免了一些潜在的错误和混淆。但需要注意，`explicit` 关键字只对单参数构造函数有效，不适用于无参构造函数或多参数构造函数。



---

### 18 c++中构造函数和析构函数可以抛出异常吗

在 C++ 中，构造函数和析构函数可以抛出异常。构造函数在对象实例化期间可能遇到错误，因此可以使用异常来处理这些错误。析构函数在对象生命周期结束时执行清理工作，也可以通过异常处理来处理清理过程中的错误情况。

然而，需要注意以下几点：

1. 当构造函数抛出异常时，对象的创建过程会被中断，对象将不会被完全构造，并立即销毁。在这种情况下，要注意处理局部对象和已分配的资源，以避免资源泄露。
2. 对象的析构函数在出现异常时也可以抛出异常。但建议在析构函数中避免抛出异常，因为当一个异常在析构函数中被抛出时，如果同时有其他异常未被处理，程序将终止。
3. 在异常处理过程中，应该小心处理可能发生的资源泄露和状态不一致等问题，以确保程序的正确和稳定。

总之，构造函数和析构函数都可以抛出异常，但在使用时需要特别小心，确保在异常情况下能够正确处理资源和状态。需要根据具体的需求和情况来决定是否抛出异常，并进行必要的异常处理。



---



### 19 C++大小端是什么，如何写代码测试大小端

大小端（Endian）是指在多字节数据存储时，字节的顺序是从高位到低位（大端）还是从低位到高位（小端）。

在小端系统中，低位字节存储在内存的低地址，高位字节存储在内存的高地址。而在大端系统中，高位字节存储在内存的低地址，低位字节存储在内存的高地址。

为了测试当前系统的大小端模式，可以编写如下的代码：

```c++
#include <iostream>

int main() {
    unsigned int value = 0x12345678;
    unsigned char* ptr = reinterpret_cast<unsigned char*>(&value);

    if (*ptr == 0x78) {
        std::cout << "Little Endian" << std::endl;
    } else {
        std::cout << "Big Endian" << std::endl;
    }

    return 0;
}
```

上述代码创建了一个无符号整型变量 `value`，初始化为 0x12345678。然后通过将 `value` 的地址转换为 `unsigned char*` 类型的指针 `ptr`，并取指针指向的值，来获取内存中的字节序。如果 `*ptr` 的值为 0x78，则表示系统是小端模式；否则为大端模式。



---

### 20 多继承有什么问题以及如何解决

多继承是 C++ 中的一项特性，允许一个类从多个基类派生。然而，多继承也会引入一些问题。

其中一个常见的问题是菱形继承问题（Diamond Inheritance Problem），也称为菱形继承二义性（Diamond Inheritance Ambiguity）。这种情况发生在一个派生类同时从两个不同的基类继承，而这两个基类又共同继承自同一个基类。这样就会在派生类中出现两个来自基类的相同成员，导致二义性。

例如，考虑以下类继承关系：

```c++
class A {
public:
    int x;
};

class B : public A {
public:
    // 可能有其他成员
};

class C : public A {
public:
    // 可能有其他成员
};

class D : public B, public C {
public:
    // 可能有其他成员
};
```

在这个例子中，类 D 继承自类 B 和类 C，而类 B 和类 C 都继承自类 A。现在，类 D 就会具有两个名为 `x` 的成员变量，一个是从类 B 中继承来的，另一个是从类 C 中继承来的，这就导致了二义性。

为了解决菱形继承问题，C++ 提供了以下解决方案：

1. 使用虚继承（Virtual Inheritance）：通过在类 B 和类 C 继承类 A 的声明中添加 `virtual` 关键字，可以使用虚继承来确保只有一个类 A 的实例被创建。这样就可以避免菱形继承问题。例如，`class B : public virtual A` 和 `class C : public virtual A`。
2. 解决二义性：如果不使用虚继承，而出现了菱形继承问题，可以在派生类 D 中使用作用域限定符来解决二义性问题。例如，可以通过 `D::B::x` 和 `D::C::x` 来访问不同的成员变量。

这些解决方案都是为了消除菱形继承引起的二义性问题，具体需要根据实际情况来选择合适的解决方案。



---



### 21 什么是虚函数表

虚函数表（Virtual Function Table，简称 vtable）是 C++ 中实现多态性的一种机制之一。它用于解决在继承关系中，通过基类指针或引用调用派生类的虚函数时的函数分派问题。

虚函数表是每个含有虚函数的类的一个隐藏的数据结构，通过该表来存储和管理虚函数的地址。每个对象实例都有一个指向对应类的虚函数表的指针，称为虚函数表指针（vptr）。

虚函数表由编译器在编译阶段生成，通常是作为类的静态成员变量。每个类的虚函数表存储了该类的虚函数的地址，以及其他关于虚函数调用的信息。

当通过基类指针或引用调用虚函数时，编译器会根据虚函数表指针的值，动态地确定调用哪个类的虚函数。具体的过程如下：

1. 编译器通过基类指针或引用找到虚函数表指针。
2. 根据虚函数表指针找到对应的虚函数表。
3. 根据函数的索引或偏移量，从虚函数表中找到要调用的虚函数的地址。
4. 调用对应的虚函数。

通过虚函数表的机制，C++ 实现了运行时多态性（Runtime Polymorphism），即通过基类指针或引用调用相应的派生类的虚函数，实现了动态的函数分派和多态行为。

需要注意的是，虚函数表是编译器和实现相关的细节，具体的实现方式可能因编译器和操作系统的不同而有所区别。不同编译器和不同环境下，虚函数表的结构和存储方式可能会有所差异。但总体原理和作用是相似的。



---

### 22 多态、虚继承、多重继承的内存布局

[c++头脑风暴-多态、虚继承、多重继承内存布局 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/381390142)

1. 一个没有虚函数的类，它的大小其实就是所有成员变量的大小，此时它就是一个由诸多成员变量组成的结构体，计算大小时同样要按照字节对齐去计算，下面所有计算大小都需按照字节对齐去计算，后面不再说明；
2. 一个没有虚函数的类派生出一个没有虚函数的派生类，那么这个派生类的内存布局就是先基类成员变量，然后派生类成员变量组成的结构体，各成员变量在内存中存储顺序按照声明时的顺序来存放；
3. 一个有虚函数的类，类本身会生成一份虚函数表，这个虚函数表是所有类对象共享的，每个类对象都会在构造时首先生成一个虚表指针，指向这个虚函数表，然后才是各个成员变量，所以有虚函数的类对象会比没有虚函数的类多一个虚表指针，虚表指针跟其他指针没有区别，在64位系统中就是占用8个字节；
4. 一个派生类非虚继承于一个有虚函数的类，不论派生类是否有同样的虚函数，它的内存布局都只是在有虚函数的基类基础上增加派生类的成员变量，虚表指针是直接继承基类的，指向基类虚表指针，如果派生类有同样的虚函数，那就覆盖基类虚表中同名函数，如果是派生类独有的虚函数，那就追加在基类虚函数表后面；
5. 一个派生类虚继承于一个有虚函数且没有成员变量的基类，则派生类也不会生成它自己的虚表指针和虚函数表，此时内存布局是首先是虚表指针，然后是派生类的成员变量，与第4点区别不大；
6. 一个派生类虚继承于一个有虚函数且有成员变量的基类，此时派生类会重新生成它自己的虚表指针和虚函数表，内存布局则是派生类的虚表指针和成员变量在前，基类的虚表指针和成员变量在后；
7. 多重继承时最好使用虚继承，否则不只是会产生令人头疼的二义性问题，还会多一份虚基类的拷贝，使用虚继承以后，大家共享虚基类，既节约了空间，又避免了二义性问题。



---

### 23  程序内存分配方式以及它们的区别

内存分配大致上可以分成5块：

1. 栈区（stack）。栈，就是那些由编译器在需要时分配，在不需要的时候自动清楚的变量的存储区。里面的变量通常是局部变量、函数参数等。
2. 堆区（heap）。一般由程序员分配、释放，若程序员不释放，程序结束时可能由系统回收。
3. 全局区（静态区）（static）。全局变量和静态变量被分配到同一块内存中。程序结束后由系统释放。
4. 常量存储区。常量字符串就是放在这里的，不允许修改，程序结束后由系统释放。
5. 程序代码区。存放函数体的二进制代码。



---



### 24 static关键字的作用

##### 全局静态变量

在全局变量前加上关键字static，全局变量就被定义成一个全局静态变量。

存放区：存放在静态存储区，在整个程序运行期间一直存在。

初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非它被显式初始化）

作用域：全局静态变量在声明它的文件之外是不可见的，准确来说作用域是从定义之处开始，到文件结尾。

##### 局部静态变量

在局部变量前加上关键字static，局部变量就被定义成一个局部静态变量。

存放区：静态存储区。

初始化：未经初始化的局部静态变量会被自动初始化为0（自动对象的值是任意的，除非它被显示初始化）

作用域：作用域仍然是局部作用域，当定义它的语句块结束时，作用域结束。但是当局部静态变量离开作用域后，并没有被销毁，而是仍然驻留在内存当中，只不过我们不能对其进行访问，除非该函数再次被调用，并且该局部静态变量值不变。

##### 静态函数

在函数返回类型前加static，函数就被定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只在声明它的文件当中可见，不能被其他文件所用。

这个函数只可以被本cpp内使用，不会和其他cpp中的同名函数引起冲突。

**类的静态成员**

在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会被破坏隐藏的原则，也就是保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。

**类的静态函数**

静态成员函数和静态成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名，可以直接使用class_name::static_func()就可以访问。



---

### 25 什么是RAII

RAII 是资源获取即初始化（Resource Acquisition Is Initialization）的缩写，是一种 C++ 的编程技术和设计模式。

RAII 的核心思想是，使用对象的构造函数在对象创建时获取资源，使用对象的析构函数在对象销毁时释放资源。这样可以确保资源在使用完毕后能够被正确释放，避免资源泄漏和内存泄漏的问题。

具体来说，使用 RAII 的方式是将资源的管理交给一个对象来处理，这个对象负责资源的获取和释放。当对象被创建时，资源会被获取；当对象被销毁时，析构函数会被调用，从而自动释放资源。这样可以确保资源的正确释放，无论在任何情况下，包括异常抛出的情况下。

常见的使用 RAII 的场景包括：

1. 动态内存管理：使用智能指针（如 std::shared_ptr、std::unique_ptr）来管理动态分配的内存，确保内存的自动释放。
2. 文件操作：使用文件句柄类来管理文件的打开和关闭，以确保文件资源的正确释放。
3. 锁的管理：使用互斥锁类（如 std::mutex）或其他同步原语的封装，通过构造函数锁定资源，析构函数自动释放锁，确保线程安全。

RAII 能够简化资源管理的代码，提高代码的可读性和可维护性，避免了手动管理资源带来的潜在错误。同时，它也是 C++ 中的一种优秀的异常安全编程方式，能够确保在异常发生时资源能够正确释放。

```c++
#include <iostream>
#include <memory>

template <typename T>
class RAII {
private:
    T* ptr;

public:
    RAII() : ptr(nullptr) {}

    RAII(T* resource) : ptr(resource) {}

    ~RAII() {
        if (ptr) {
            delete ptr;
        }
    }

    T* get() const {
        return ptr;
    }

    void reset(T* resource) {
        if (ptr) {
            delete ptr;
        }
        ptr = resource;
    }

    T& operator*() const {
        return *ptr;
    }

    T* operator->() const {
        return ptr;
    }
};

int main() {
    RAII<int> raii(new int(42));

    std::cout << *raii << std::endl; // 输出：42

    (*raii)++;
    std::cout << *raii << std::endl; // 输出：43

    raii.reset(new int(100));
    std::cout << *raii << std::endl; // 输出：100

    return 0;
}
```



---

### 26 C++ 中的关键字

##### C++11

1. `auto`: 用于自动推导变量的类型。编译器会根据变量的初始化表达式自动推导出变量的类型。
2. `nullptr`: 用于表示空指针，替代了传统的 `NULL`。`nullptr` 具有明确的类型，可以避免因类型不匹配而引发的问题。
3. `decltype`: 用于获取表达式的类型，可以用于定义变量或函数返回类型，避免类型重复定义。
4. `constexpr`: 用于声明常量表达式，可以在编译时求值。被声明为 `constexpr` 的变量或函数可以在编译时进行计算，提高了性能和编译时检查。
5. `static_assert`: 用于在编译时进行断言检查，如果条件不满足，会导致编译错误。可以用于进行静态的类型检查和条件验证。
6. `override`: 用于显式地标记派生类中覆盖基类虚函数的成员函数，以增加代码的可读性和可维护性。
7. `final`: 用于禁止派生类对基类虚函数的进一步覆盖，以增加代码的安全性和可靠性。

8. `default`: 用于声明默认的特殊成员函数。当一个类需要默认的构造函数、析构函数、拷贝构造函数、拷贝赋值运算符或移动构造函数时，可以使用 `default` 关键字显式声明该特殊成员函数为默认的实现。这使得编译器可以自动生成默认的实现，而无需手动编写。
9. `delete`: 用于禁用特殊成员函数或普通成员函数。通过在函数声明中使用 `delete` 关键字可以阻止该函数的使用。这对于防止特定函数的意外调用或禁止某些类型的操作非常有用。



---

### 27 引用和指针的区别

C++引用和指针是两种不同的变量类型，它们有以下区别：

1. 定义和使用方式：指针使用`*`来声明和操作，而引用使用`&`来声明。指针可以为空（nullptr），但引用必须在声明时初始化，并且一旦初始化后不能改变引用的目标。
2. 空值：指针可以为空（null），表示不指向任何对象。引用必须引用一个已经存在的对象，不能为空。
3. 内存分配：指针可以通过`new`运算符动态分配内存，也可以指向栈上的对象。引用只能引用栈上的对象。
4. 重新赋值：指针可以通过改变指向来引用不同的对象，或者将指针设置为空。引用一旦初始化后，不能改变引用的目标。
5. 空间占用：指针通常占用4个或8个字节的空间，根据操作系统的位数和编译器的实现而定。引用不占用额外的空间，它只是目标对象的别名。
6. 空间访问：指针可以访问指向对象的成员，通过解引用操作符`*`和成员访问操作符`.`。引用可以直接通过成员访问操作符`.`访问目标对象的成员。
7. 空间操作：指针可以进行空间操作，如指针运算（加减指针）、比较（大于、小于等）、指针的递增和递减等。引用不能进行空间操作。

总的来说，指针更加灵活，可以为空、可以指向不同的对象，可以进行空间操作；而引用更加简洁，不能为空、不能改变目标对象、不能进行空间操作，但更安全且易于使用。



---



### 28 volatile的作用

volatile是 C 语言中的一个关键字，用于修饰变量，表示该变量的值可能在任何时候被外部因素更改，例如硬件设备、操作系统或其他线程。

当一个变量被声明为volatile时，编译器会禁止对该变量进行优化，以确保每次访问变量时都会从内存中读取其值，而不是从寄存器或缓存中读取。

避免因为编译器优化而导致出现不符合预期的结果



---



### 29 define和typedef的区别

##### 区别

**语法和实现机制：**

- 宏定义 #define 在编译期间将宏展开，并替换宏定义中的代码。预处理器只进行简单的文本替换，不涉及类型检查。

​	比如：

```c++
#define INT_VECTOR std::vector<int>
```

- typedef 是一种类型定义关键字，用于为现有类型创建新的名称（别名）。


​	与宏定义不同，typedef 是在编译阶段处理的，有更严格的类型检查。

```
typedef std::vector<int> IntVector;
```

**作用域限制：**

- 宏定义没有作用域限制，只要在宏定义之后的地方，就可以使用宏。

​	通常用于定义常量、简单的表达式或简单的代码片段。

- typedef 遵循 C++ 的作用域规则，可以受到命名空间、类等结构的作用域限制。


​	typedef 通常用于定义复杂类型的别名，使代码更易读和易于维护，如：

```c++
typedef std::map<std::string, std::vector<int>> StringToIntVectorMap;
```

**模板支持：**
	宏定义不支持模板，因此不能用于定义模板类型别名。

```c++
// typedef 可以与模板结合使用，但在 C++11 之后，推荐使用 using 关键字定义模板类型别名。

// 使用 typedef 定义模板类型别名
template <typename T>
struct MyContainer {
    typedef std::vector<T> Type;
};

// 使用 using 定义模板类型别名（C++11 及以后）
template <typename T>
struct MyContainer {
    using Type = std::vector<T>;
};
```



---

### 30 C/C++中数组做参数退化为指针

##### 数组本身作为参数

如下代码：

```c++
int func(char array[]) {
    printf("sizeof=%d\n", sizeof(array));
    printf("strlen=%d\n", strlen(array));
}

int main() {
    char array[] = "Hello World";
    printf("sizeof=%d\n", sizeof(array));
    printf("strlen=%d\n", strlen(array));
    func(array);
}
```

64位机器输出结果

```c++
sizeof=12
strlen=11
sizeof=8   // ?
strlen=11
```

这里涉及到一个概念：**数组退化为指针**。

**数组退化：在 C++ 中，数组在作为函数参数时会退化为指向其首元素的指针。**

退化的原因是因为数组作为函数参数时，实际传递的是指向数组首元素的指针，不可能逐个拷贝整个数组然后在栈上传递，所以编译器只知道参数是一个指针，而不知道它的长度信息。



##### 数组的引用作为参数

如下代码：

```c++
#include <iostream>
#include <cstring>
template <typename T, std::size_t N>
void printSizeAndLength(const T (&arr)[N]) {
    std::cout << "Size of arr in function: " << sizeof(arr) << std::endl; // 计算数组的大小
    std::cout << "Length of arr: " << strlen(arr) << std::endl; // 计算字符串的长度
}
int main() {
    char str[] = "Hello, world!";
    std::cout << "Size of str in main: " << sizeof(str) << std::endl; // 计算整个字符数组的大小
    printSizeAndLength(str);
}
```

输出结果：

```c++
Size of str in main: 14
Size of arr in function: 14
Length of arr: 13
```

这段代码使用了模板函数 printSizeAndLength，它接受一个数组引用作为参数。

在函数内部，使用 sizeof 计算数组的大小时，数组不会退化为指针。

引用的作用就在于阻止拷贝的发生，通过传递引用，让形参得到和数组名同样的地址。



---

### 31 C++字节对齐

在C/C++中，字节对齐是内存分配的一种策略。

当分配内存时，编译器会自动调整数据结构的内存布局，使得数据成员的起始地址与其自然对齐边界（一般为自己大小的倍数）相匹配。

**以下是字节对齐的一些基本规则：**

- **自然对齐边界**

  对于基本数据类型，其自然对齐边界通常为其大小。

​		例如，char 类型的自然对齐边界为 1 字节，short 为 2 字节，int 和 float 为 4 字节，double 和 64 位指针为 8 字节。具体数值可能因编译器和平台而异。

- **结构体对齐**

  结构体内部的每个成员都根据其自然对齐边界进行对齐。也就是可能在成员之间插入填充字节。

​		结构体本身的总大小也会根据其最大对齐边界的成员进行对齐（比如结构体成员包含的最长类型为int类型，那么整个结构体要按照4的倍数对齐），以便在数组中正确对齐。

- **联合体对齐**

  联合体的对齐边界取决于其最大对齐边界的成员。联合体的大小等于其最大大小的成员，因为联合体的所有成员共享相同的内存空间。

- **编译器指令**

  可以使用编译器指令（如 #pragma pack）更改默认的对齐规则。这个命令是全局生效的。这可以用于减小数据结构的大小，但可能会降低访问性能。

- **对齐属性**

  在 C++11 及更高版本中，可以使用 alignas 关键字为数据结构或变量指定对齐要求。这个命令是对某个类型或者对象生效的。例如，alignas(16) int x; 将确保 x 的地址是 16 的倍数。

- **动态内存分配**

  大多数内存分配函数（如 malloc 和 new）会自动分配足够对齐的内存，以满足任何数据类型的对齐要求。

**例如**

```c++
#include <iostream>

#pragma pack(push, 1) // 设置字节对齐为 1 字节，取消自动对齐
struct UnalignedStruct {
    char a;
    int b;
    short c;
};
#pragma pack(pop) // 恢复默认的字节对齐设置

struct AlignedStruct {
    char a;   // 本来1字节，padding 3 字节
    int b;    //  4 字节
    short c;  // 本来 short 2字节，但是整体需要按照 4 字节对齐(成员对齐边界最大的是int 4) 
              // 所以需要padding 2
   // 总共: 4 + 4 + 4
};

struct MyStruct {
 double a;    // 8 个字节
 char b;      // 本来占一个字节，但是接下来的 int 需要起始地址为4的倍数
              //所以这里也会加3字节的padding
 int c;       // 4 个字节
 // 总共:  8 + 4 + 4 = 16
};

struct MyStruct1 {
 char b;    // 本来1个字节 + 7个字节padding
 double a;  // 8 个字节
 int c;     // 本来 4 个字节，但是整体要按 8 字节对齐，所以 4个字节padding
  // 总共: 8 + 8 + 8 = 24
};
// MyStruct 和 MyStruct1由于由于结构体成员的类型和顺序不同，导致字节对齐规则存在差异

int main() {
    std::cout << "Size of unaligned struct: " << sizeof(UnalignedStruct) << std::endl; 
    // 输出：7
    std::cout << "Size of aligned struct: " << sizeof(AlignedStruct) << std::endl; 
    // 输出：12，取决于编译器和平台
    std::cout << "Size of aligned struct: " << sizeof(MyStruct) << std::endl; 
    // 输出：16，取决于编译器和平台
    std::cout << "Size of aligned struct: " << sizeof(MyStruct1) << std::endl;
     // 输出：24，取决于编译器和平台
    return 0;
}

```



---



### 32 extern的作用

一般而言，C++全局变量的作用范围仅限于当前的文件，但同时C++也支持分离式编译，允许将程序分割为若干个文件被独立编译。

于是就需要在文件间共享变量数据，这里extern就发挥了作用。

extern 用于指示变量或函数的定义在另一个源文件中，并在当前源文件中声明。 说明该符号具有外部链接(external linkage)属性。

也就是告诉编译器: 这个符号在别处定义了，你先编译，到时候链接器会去别的地方找这个符号定义的地址。

> **凡是没有带extern的声明同时也都是定义**。 而对函数而言，带有{}是定义，否则是声明。如果想声明一个变量而非定义它，就在变量名前添加关键字extern，且不要显式的初始化变量。



---



### 33  extern C 的作用

extern 是指示链接可见性和符号规则，而 extern "C" 则是 C++ 语言提供的一种机制，用于在 C++ 代码中调用 C 语言编写的函数和变量。

如果不用 extern C，由于 C++ 和 C 语言在编译和链接时使用的命名规则不同，这会导致 C++ 代码无法调用 C 语言编写的函数或变量（链接时找不到符号）。

**extern "C" 的语法格式如下：**

```c++
extern "C" {
    // C 语言函数或变量的声明
}
```



---



### 34 mutable的作用

mutable是C++中的一个关键字，用于修饰类的成员变量，表示该成员变量即使在一个const成员函数中也可以被修改。

如果需要在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰



---



### 35 面向对象三大特性

C++ 面向对象编程 (OOP) 的三大特性包括：**封装、继承和多态**。

##### 封装（Encapsulation）

封装是将数据（属性）和操作这些数据的函数（方法）组合在一个类（Class）中的过程。

封装的主要目的是隐藏类的内部实现细节，仅暴露必要的接口给外部。

通过封装，我们可以控制类成员的访问级别（例如：public、protected 和 private），限制对类内部数据的直接访问，确保数据的完整性和安全性。

##### 继承（Inheritance）

继承是一个类（派生类，Derived Class）从另一个类（基类，Base Class）那里获得其属性和方法的过程。

继承允许我们创建具有共享代码的类层次结构，减少重复代码，提高代码复用性和可维护性。

在 C++ 中，访问修饰符（如 public、protected、private）控制了派生类对基类成员的访问权限。

##### 多态（Polymorphism）

多态是允许不同类的对象使用相同的接口名字，但具有不同实现的特性。

在 C++ 中，多态主要通过虚函数（Virtual Function）和抽象基类（Abstract Base Class）来实现。

虚函数允许在派生类中重写基类的方法，而抽象基类包含至少一个纯虚函数（Pure Virtual Function），不能被实例化，只能作为其他派生类的基类。

通过多态，我们可以编写更加通用、可扩展的代码，提高代码的灵活性。

> 总结：封装、继承和多态是面向对象编程的三大核心特性，能够帮助我们编写更加模块化、可重用和可维护的代码。
>



---

### 36 C++ 类成员访问权限

有三种访问修饰符：public、private 和 protected，分别定义了类成员的访问级别，控制类成员的可见性和可访问性。

##### public（公共）

公共成员在任何地方都是可访问的。

调用方可以直接访问和修改公共成员，公共访问修饰符通常用于类的外部接口。

但是一般情况下，不建议将类的成员变量设置为 public，因为这不符合封装的原则。

```c++
class MyClass {
public:
    int x;
};
```

x 是一个公共成员，可以在类的对象中被访问。

##### private（私有）

私有成员只能在类的内部访问，即仅在类的成员函数中可以访问。

私有成员用于实现类的内部实现细节，这些细节对于类的用户来说是隐藏的。

```c++
class MyClass {
private:
    int x;
};
```

上面的x 是一个私有成员，不能在类的外部被直接访问，要想访问 x，必须由 MyClass 封装一些对外的 public 函数。

##### protected（受保护）

受保护成员类似于私有成员，但它们可以被派生类访问。

受保护成员通常用于继承和多态等场景，这样子类也可以访问父类的成员变量。

```c++
class MyBaseClass {
protected:
    int x;
};

class MyDerivedClass : public MyBaseClass {
public:
    void setX(int a) {
        x = a;
    }
};
```



---



### 37 重载、重写、隐藏的区别

##### 重载

重载是指**相同作用域**(比如命名空间或者同一个类)内拥有相同的方法名，但具有**不同的参数类型和/或参数数量**的方法。 重载允许根据所提供的参数不同来调用不同的函数。它主要在以下情况下使用：

- 方法具有相同的名称。
- 方法具有不同的参数类型或参数数量。
- 返回类型可以相同或不同。
- 同一作用域，比如都是一个类的成员函数，或者都是全局函数

如：

```C++
class OverloadingExample {
  void display(int a) {
    System.out.println("Display method with integer: " + a);
  }

  void display(String b) {
    System.out.println("Display method with string: " + b);
  }
}
```



##### 重写

重写是指在**派生类中重新定义基类**中的方法。

当派生类需要改变或扩展基类方法的功能时，就需要用到重写。

重写的条件包括：

- 方法具有相同的名称。

- 方法具有相同的参数类型和数量。
- 方法具有相同的返回类型。
- 重写的基类中被重写的函数必须有virtual修饰。
- 重写主要在继承关系的类之间发生。

如：

```C++
#include <iostream>

class BaseClass {
public:
    virtual void display() {
        std::cout << "Display method in base class" << std::endl;
    }
};

class DerivedClass : public BaseClass {
public:
    void display() override {
        std::cout << "Display method in derived class" << std::endl;
    }
};

int main() {
    DerivedClass derived;
    derived.display();

    return 0;
}
```

##### 隐藏

隐藏是指派生类的函数屏蔽了与其同名的基类函数。注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。 

如：

```C++
#include<iostream>
using namespace std;

classA{
public:
  void fun1(int i, int j){
    cout <<"A::fun1() : " << i <<" " << j << endl;
  }
};
classB : public A{
public:
  //隐藏
  void fun1(double i){
    cout <<"B::fun1() : " << i << endl;
  }
};
int main(){
  B b;
  b.fun1(5);//调用B类中的函数
  b.fun1(1, 2);//出错，因为基类函数被隐藏
  system("pause");
  return 0;
}
```

##### 重载和重写的区别：

**范围区别：**重写和被重写的函数在不同的类中，重载和被重载的函数在同一类中（同一作用域）。
**参数区别：**重写与被重写的函数参数列表一定相同，重载和被重载的函数参数列表一定不同。
**virtual的区别**：重写的基类必须要有virtual修饰，重载函数和被重载函数可以被virtual修饰，也可以没有。

##### 隐藏和重写，重载的区别：

**与重载范围不同**：隐藏函数和被隐藏函数在不同类中。
**参数的区别：**隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被重写



---



### 38 C++ 类对象的初始化和析构顺序

##### 初始化顺序

1. **基类初始化顺序**

如果当前类继承自一个或多个基类，它们将按照声明顺序进行初始化，但是在有虚继承和一般继承存在的情况下，优先虚继承。

比如虚继承：`class MyClass : public Base1, public virtual Base2`，此时应当先调用 Base2 的构造函数，再调用 Base1 的构造函数。

2. **成员变量初始化顺序**

类的成员变量按照它们在类定义中的声明顺序进行初始化。

3. **执行构造函数**

在基类和成员变量初始化完成后，执行类的构造函数。

**栗子：**

```C++
#include <iostream>

class Base {
public:
    Base() { std::cout << "Base constructor" << std::endl; }
    ~Base() {
        std::cout << "Base destructor" << std::endl;
    }
};

class Base1 {
public:
    Base1() { std::cout << "Base1 constructor" << std::endl; }
    ~Base1() {
        std::cout << "Base1 destructor" << std::endl;
    }
};

class Base2 {
public:
    Base2() { std::cout << "Base2 constructor" << std::endl; }
    ~Base2() {
        std::cout << "Base2 destructor" << std::endl;
    }
};

class Base3 {
public:
    Base3() { std::cout << "Base3 constructor" << std::endl; }
    ~Base3() {
        std::cout << "Base3 destructor" << std::endl;
    }
};

class MyClass : public virtual Base3, public Base1, public virtual Base2 {
public:
    MyClass() : num1(1), num2(2) {
        std::cout << "MyClass constructor" << std::endl;
    }
    ~MyClass() {
        std::cout << "MyClass destructor" << std::endl;
    }

private:
    int num1;
    int num2;
    // 这个是为了看成员变量的初始化顺序
    Base base;
};

int main() {
    MyClass obj;
    return 0;
}
```

**结果**

```C++
Base3 constructor  // 虚继承排第一
Base2 constructor  // 虚继承优先
Base1 constructor  // 普通基类
Base constructor   // 成员函数构造
MyClass constructor // 构造函数
```



##### 析构顺序

**类的析构顺序和构造顺序完全相反**

还是上面的代码

```C++
Base3 constructor
Base2 constructor
Base1 constructor
Base constructor
MyClass constructor
MyClass destructor
Base destructor
Base1 destructor
Base2 destructor
Base3 destructor
```



---

### 39 为什么C++构造函数不能是虚函数

##### 从语法层面来说

虚函数的主要目的是实现多态，即允许在派生类中覆盖基类的成员函数。

但是，构造函数负责初始化类的对象，每个类都应该有自己的构造函数。

在派生类中，基类的构造函数会被自动调用，用于初始化基类的成员。因此，构造函数没有被覆盖的必要，不需要使用虚函数来实现多态。

##### 从虚函数表机制回答

虚函数使用了一种称为虚函数表（vtable）的机制。然而，在调用构造函数时，对象还没有完全创建和初始化，所以虚函数表可能尚未设置。

这意味着在构造函数中使用虚函数表会导致未定义的行为。

只有执行完了对象的构造，虚函数表才会被正确的初始化。



---



### 40 为什么 C++ 基类析构函数需要是虚函数？

当一个派生类继承自一个基类时

- 若基类的析构函数不是虚函数，当用基类指针指向派生类时，`Base* ptr = new Derived();`，当析构函数被调用时，只会执行基类的析构函数，而不执行派生类的析构函数。
- 若基类的析构函数是虚函数，则会先执行派生类的析构函数，再执行基类的析构函数

**栗子：**

基类析构函数没有定义为虚函数：

```C++
#include <iostream>

class Base {
public:
    // 注意，这里的析构函数没有定义为虚函数
    ~Base() {
        std::cout << "Base destructor called." << std::endl;
    }
};

class Derived : public Base {
public:
    Derived() {
        resource = new int[100]; // 分配资源
    }

    ~Derived() {
        std::cout << "Derived destructor called." << std::endl;
        delete[] resource; // 释放资源
    }

private:
    int* resource; // 存储资源的指针
};

int main() {
    Base* ptr = new Derived();
    delete ptr; // 只会调用Base的析构函数，Derived的析构函数不会被调用
    return 0;
}
```

输出结果

```c++
Base destructor called.
```

基类析构函数定义为虚函数：

```C++
class Base {
public:
    virtual ~Base() {
        std::cout << "Base destructor called." << std::endl;
    }
};

class Derived : public Base {
public:
    ~Derived() {
        std::cout << "Derived destructor called." << std::endl;
    }
};

int main() {
    Base* ptr = new Derived();
    delete ptr; // 调用Derived的析构函数，然后调用Base的析构函数
    return 0;
}

```

输出结果

```C++
Derived destructor called.
Base destructor called.
```



**为什么默认的析构函数不是虚函数？**

当类中有虚成员函数时，类会自动生成虚函数表和虚表指针，虚表指针指向虚函数表；

这样一来，就会占用额外的内存，当们定义的类不被其他类继承时，这种内存开销无疑是浪费的。



**总结**
在C++中，基类的析构函数需要定义为虚函数，以确保在通过基类指针或引用删除派生类对象时，能够正确地调用派生类的析构函数，否则派生类的析构函数不会被调用，这部分资源也就并无法被释放。

将基类的析构函数定义为虚函数后，C++运行时会自动识别指向的对象的实际类型，并确保调用正确的派生类析构函数。

当派生类析构函数执行完毕后，基类的析构函数也会自动调用，以确保对象完全销毁。



---



### 41 sizeof 一个空类大小是多大

**栗子：**

```c++
class Empty {};

int main() {
    Empty e1;
    Empty e2;
    std::cout << "Size of Empty class: " << sizeof(Empty) << std::endl;
}
```

输出结果：

```
Size of Empty class: 1
```

**原因**

这是因为C++标准要求每个对象都必须具有独一无二的内存地址。

为了满足这一要求，编译器会给每个空类分配一定的空间，通常是1字节。

这样，即使是空类，也能保证每个实例都有不同的地址。



---



### 42 为什么C++的成员模板函数不能是 virtual 的

**问题**

比如下面这段代码会报错

```C++
class Animal{
  public:
      template<typename T>
      virtual void make_sound(){
        //...
      }
};
```

**原因**

因为C++的编译与链接模型是"分离"的。

- 从Unix/C开始，一个C/C++程序就可以被分开编译，然后用一个linker链接起来。这种模型有一个问题，就是各个编译单元可能对另一个编译单元一无所知。

- 一个 function template最后到底会被 instantiate 为多少个函数，要等整个程序(所有的编译单元)全部被编译完成才知道。
- 同时，virtual function的实现大多利用了一个"虚函数表"的东西，这种实现中，一个类的内存布局(或者说虚函数表的内存布局)需要在这个类编译完成的时候就被完全确定。

所以当一个虚拟函数是模板函数时，编译器在编译时无法为其生成一个确定的虚函数表条目，因为模板函数可以有无数个实例。但是编译时无法确定需要调用哪个特定的模板实例。因此，C++标准规定member function 不能既是 template 又是 virtual 的。



---



### 43 不能对void型指针解引用

```C++
int num;
void *pv = (void*)&num;
*pv = 4; // 错误
```

因为解引用的本质就是编译器根据指针所指的类型，然后从指针所指向的内存连续取 N 个字节，然后将这 N 个字节按照指针的类型去解释。

比如 int *型指针，那么这里 N 就是 4，然后按照 int 的编码方式去解释数字。

但是 void，编译器是不知道它到底指向的是 int、double、或者是一个结构体，所以编译器没法对 void 型指针解引用。



---



### 44 野指针和空悬指针

##### 野指针（Wild Pointer）

野指针是一个未被初始化或已被释放的指针。

所以它的值是不确定的，可能指向任意内存地址。

访问野指针可能导致未定义行为，如程序崩溃、数据损坏等。

以下是一个野指针的例子：

```c++
#include <iostream>

int main() {
    int *wild_ptr; // 未初始化的指针，值不确定
    std::cout << *wild_ptr << std::endl; // 访问野指针，可能导致未定义行为
    return 0;
}
```

##### 空悬指针（Dangling Pointer）

空悬指针是指向已经被释放（如删除、回收）的内存的指针。

这种指针仍然具有以前分配的内存地址，但是这块内存可能已经被其他对象或数据占用。

访问空悬指针同样会导致未定义行为。

以下是一个空悬指针的例子：

```c++
#include <iostream>

int main() {
    int *ptr = new int(42);
    delete ptr; // 释放内存

    // 此时，ptr成为一个空悬指针，因为它指向的内存已经被释放
    std::cout << *ptr << std::endl; // 访问空悬指针，可能导致未定义行为
    return 0;

}
```

> 为了避免野指针和空悬指针引发的问题，我们应该：
>
> - 在使用指针前对其进行初始化，如将其初始化为nullptr。
> - 在释放指针指向的内存后，将指针设为nullptr，避免误访问已释放的内存。
> - 在使用指针前检查其有效性，确保指针指向合法内存。



### 45 常见的C/C++内存错误

##### 间接引用坏指针

要知道进程的虚拟地址空间中有较大的空洞，没有映射到任何有意义的数据。

如果我们试图间接引用一个指向这些空洞的指针，那么操作系统就会以段异常中止程序。

而且，虚拟内存的某些区域是只读的，试图写这些区域将会以保护异常中止这个程序。

间接引用坏指针的一个常见示例是经典的 scanf 错误。

假设我们想要使用 scanf 从 stdin 读一个整数到一个变量。

正确的方法是传递给 scanf 一个格式串和变量的地址：

```c++
int val;
scanf("%d", &val);
```

然而，对于不少 C/C++ 初学者而言（对有经验者也是如此！），很容易传递 val 的内容，而不是它的地址：

```C++
scanf("%d", val);
```

在这种情况下，scanf 将把 val 的内容解释为一个地址，并试图将一个字写到这个位置。

在最好的情况下，程序立即以异常终止。在最糟糕的情况下，val 的内容对应于虚拟内存的某个合法的读/写区域，于是我们就覆盖了这块内存。

##### 读未初始化的内存

虽然 bss 内存位置（诸如未初始化的全局 C 变量）总是被加载器初始化为零，但是对于堆内存却并不是这样的。

一个常见的错误就是假设堆内存被初始化为零：

```C++
/* Return y = Ax */
int *matvec(int **A, int *x, int n)
{
    int i, j;
    int *y = (int *)Malloc(n * sizeof(int));

    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            y[i] += A[i][j] * x[j];
    return y;
}
```


在这个示例中，程序员不正确地假设向量 y 被初始化为零。正确的实现方式是显式地将 y[i] 设置为零，或者使用 calloc。

##### 栈缓冲区溢出

如果一个程序不检查输入串的大小就写入栈中的目标缓冲区，那么这个程序就会有缓冲区溢出错误（buffer overflow bug）。

例如，下面的函数就有缓冲区溢出错误，因为 gets 函数复制一个任意长度的串到缓冲区。

为了纠正这个错误，必须使用 fgets 函数，这个函数限制了输入串的大小：

```c++
void bufoverflow()
{
    char buf[64];
    gets(buf); /* Here is the stack buffer overflow bug */
    return;
}
```

##### 误解指针运算

另一种常见的错误是忘记了指针的算术操作是以它们指向的对象的大小为单位来进行的，而这种大小単位并不一定是字节。

例如，下面函数的目的是扫描一个 int 的数组，并返回一个指针，指向 val 的首次出现：

```c++
int *search(int *p, int val)
{
    while (*p && *p != val)
        p += sizeof(int); /* Should be p++ */
    return p;
}
```

##### 引用不存在的变量

没有太多经验的 C 程序员不理解栈的规则，有时会引用不再合法的本地变量，如下列所示：

```c++
int *stackref ()
{
    int val;
    return &val;
}
```


这个函数返回一个指针（比如说是 p , `int* p = stackred() `），指向栈里的一个局部变量，然后弹出它的栈帧。 尽管 p 仍然指向一个合法的内存地址，但是它已经不再指向一个合法的变量了。 当以后在程序中调用其他函数时，内存将重用它们的栈帧。再后来，如果程序分配某个值给 *p，那么它可能实际上正在修改另一个函数的栈帧中的一个条目，从而潜在地带来灾难性的、令人困惑的后果。

##### 引起内存泄漏

内存泄漏是缓慢、隐性的杀手，当程序员不小心忘记释放已分配块，而在堆里创建了垃圾时，会发生这种问题。例如，下面的函数分配了一个堆块 x，然后不释放它就返回：

```c++
void leak(int n)
{
    int *x = (int *)Malloc(n * sizeof(int));
    return;  /* x is garbage at this point */
}
```



---



### 46 什么情况下需要回避虚函数机制，以及如何回避？

​		当一个派生类的虚函数调用它覆盖的基类的虚函数版本时，如果不加以回避，则在调用过程中将被解析为对派生类版本自身的调用，从而导致无限递归。

​		也就是说在这种情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本（如基类的虚函数）。

​		可以通过作用域运算符( :: )实现这一目的。

​		比如：

```c++
double money = baseptr->base::price();
```



---



### 47 什么是纯虚函数

与普通的虚函数不同，一个纯虚函数无需定义，我们通过在函数体的位置（即在声明语句的分号之前）书写 **=0** 就可以将一个虚函数声明为纯虚函数，如：

```c++
virtual double func() =0;
```

含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类，如果派生类没有覆盖纯虚函数，则派生类仍然是抽象基类。

抽象基类负责定义接口，而后续的其他类可以覆盖该接口。

我们不能（直接）创建一个抽象基类的对象；





---



### 48 从源代码到可执行文件流程

**参考文章：[从源文件到可执行文件的过程 - 简书 (jianshu.com)](https://www.jianshu.com/p/6f5775ef7058)**

C语言由源码变成可以运行的可执行文件包括四个阶段，分别是

- \- 预处理阶段(预处理器)
- \- 编译阶段(编译器)
- \- 汇编阶段(汇编器)
- \- 链接阶段(链接器)



<img src="C:\Users\WangZhe\AppData\Roaming\Typora\typora-user-images\image-20231109220905305.png" alt="image-20231109220905305" style="zoom:50%;" />

![image-20231109223949110](C:\Users\WangZhe\AppData\Roaming\Typora\typora-user-images\image-20231109223949110.png)

##### 预处理

```shell
g++ -E -I include/ main.cpp -o main.i
```

> 上述命令中： - `g++ -E` 是让编译器在预处理之后就退出，不进行后续编译过程， `-I include/`用于指定头文件目录 - `main.cpp`是要预处理的源文件 - `-o main.i`用于指定生成的文件名

处理的第一步，是将源码文件.c和头文件.h编译成一个.i文件。

- 将所有的“#define”删除，并且展开所有的宏定义。
- 处理所有条件预编译指令，比如“#if”、“#ifdef”、“#elif”、“#else”、“#endif”。
- 处理“#include”预编译指令，将被包含的文件插入到该编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件。
- 删除所有的注释“//”、“/* */”
- 添加行号和文件名标识，比如#2 “hello.c” 2，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。
- 保留所有的#pragma编译器指令，因为编译器须要使用它们。



##### 编译

```shell
g++ -S -I include/ main.cpp -o main.s
```

编译过程一般分为6步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化。

![image-20231109221438548](C:\Users\WangZhe\AppData\Roaming\Typora\typora-user-images\image-20231109221438548.png)

- **扫描**

扫描阶段也称为词法分析。编译器将源代码作为输入，对其进行扫描，将源代码分割为一个个的词素（Token）。词素是源代码中的基本语义单元，如关键字、变量名、运算符、常量等。

```
<token-name,attribute-value>
```

- **语法分析**

语法分析阶段将词素序列转换为语法结构。编译器会根据语法规则（通常由上下文无关文法定义），利用递归下降、算符优先、LR等语法分析算法，来构建语法树或抽象语法树（AST）。语法分析会检查词法单元是否符合语法规则。

- **语义分析**

语义分析阶段对语法树或抽象语法树进行分析，检查代码的语义正确性。在此阶段，编译器会执行诸如类型检查、作用域分析、检查变量和函数的声明与引用的一致性等任务。语义分析确保程序在语义上是合法的，并发现潜在的错误。

- **生成IR（中间代码）**

在生成中间代码阶段，编译器将语法树或抽象语法树转换为一种中间表示形式。这种中间代码通常由一组高级语言无关的指令组成，它既比源代码更接近目标代码，又比目标代码更容易进行优化和转换。



##### 汇编

```shell
g++ -c -I include/ main.cpp -o main.o
```

将编译完的汇编代码文件翻译成机器指令，并生成可重定位目标程序的.o文件，该文件为二进制文件（目标文件）。

汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译即可。



##### 链接

```shell
g++ src/func.o main.o -o main.out
```

- **静态链接**

  >  在我们的实际开发中，不可能将所有代码放在一个源文件中，所以会出现多个源文件，而且多个源文件之间不是独立的，而会存在多种依赖关系，如一个源文件可能要调用另一个源文件中定义的函数，但是每个源文件都是独立编译的，即每个*.c文件会形成一个*.o文件，为了满足前面说的依赖关系，则需要将这些源文件产生的目标文件进行链接，从而形成一个可以执行的程序。这个链接的过程就是静态链接

  - **第一步 空间与地址分配**

    扫描所有的输入目标文件（.o），获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有到符号定义和符号引用收集起来，统一放到一个全局符号表。

    这一步中，链接器将能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系。

  - **第二步 符号解析与重定位**

    使用上面第一步中收集到的所有信息，读取输入文件汇总段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。

    事实上第二步是链接过程的核心，特别是重定位过程。

    > - **符号（Symbol）** 这个概念随着汇编语言的普及迅速被使用，它用来表示一个地址，这个地址可能是一段子程序（后来发展成函数）的起始地址，也可以是一个变量的起始地址。
    > - 重新计算各个目标的地址的过程被叫做**重定位(Relocation)**

- **动态链接**

空间浪费是静态链接的一个问题，另一个问题是静态链接对程序的更新、部署和发布也会带来很多麻烦。

为了解决这两个问题最简单的办法就是把程序的模块相互分割开来，形成独立的文件，而不将它们静态地链接在一起。

简单地讲，就是不对那些组成程序的目标文件进行链接，等到程序要运行的才进行链接。也就是说，把链接这个过程推迟到了运行时再进行，这就是**动态链接**的基本思想。

> 假设现在有两个程序program1.o和program2.o，这两者共用同一个库lib.o,假设首先运行程序program1，系统首先加载program1.o，当系统发现program1.o中用到了lib.o，即program1.o依赖于lib.o，那么系统接着加载lib.o，如果program1.o和lib.o还依赖于其他目标文件，则依次全部加载到内存中。当program2运行时，同样的加载program2.o，然后发现program2.o依赖于lib.o，但是此时lib.o已经存在于内存中，这个时候就不再进行重新加载，而是将内存中已经存在的lib.o映射到program2的虚拟地址空间中，从而进行链接（这个链接过程和静态链接类似）形成可执行程序。



##### 生成可执行文件

链接器负责将多个目标文件合并为一个可执行文件。



---

### 49 extern "C"

[详细剖析 extern "C"-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1778866)

`extern "C"` 是C++中的一个语法修饰符，用于指定按照C语言的规则进行函数名和变量名的链接。C++在函数和变量名的链接上采用了一种称为名字修饰（name mangling）的机制，该机制使得不同的函数可以拥有相同的名称，但通过函数参数的类型和个数进行区分。

当在C++中调用C语言编写的函数时，需要使用 `extern "C"`，以确保C++编译器按照C语言的链接规则来处理函数名。这对于与其他语言或通过动态链接库（DLL）交互的情况也很重要，因为C语言是通用的二进制接口（ABI）标准。

**链接规范的用法有两种：**

- 单个声明的链接规范，比如：

```javascript
extern "C" void foo();
```

- 一组声明的链接规范，比如：

```javascript
extern "C"
{
　　void foo();
　　int bar();
}
```



**Q ：** **为什么不能把#include 指令放置在 extern "C" { ... } 里面？**

**A：**

一个栗子：现有a.h，b.h，c.h以及foo.cpp，其中foo.cpp包含c.h，c.h包含b.h，b.h包含a.h

<img src="C:\Users\WangZhe\AppData\Roaming\Typora\typora-user-images\image-20231113215037886.png" alt="image-20231113215037886" style="zoom:50%;" />

现使用C++编译器的预处理选项来编译foo.cpp，得到下面的结果：

<img src="C:\Users\WangZhe\AppData\Roaming\Typora\typora-user-images\image-20231113215059414.png" alt="image-20231113215059414" style="zoom:50%;" />

当把#include指令放置在extern "C" { }里的时候，则会造成extern "C" { } 的嵌套。这种嵌套是被C++规范允许的。当嵌套发生时，以最内层的嵌套为准。

比如在下面代码中，函数foo会使用C++的链接规范，而函数bar则会使用C的链接规范。

<img src="C:\Users\WangZhe\AppData\Roaming\Typora\typora-user-images\image-20231113215143339.png" alt="image-20231113215143339" style="zoom:50%;" />

如果能够保证一个C语言头文件直接或间接依赖的所有头文件也都是C语言的，那么按照C++语言规范，这种嵌套应该不会有什么问题。

但具体到某些编译器的实现，比如MSVC2005中可能由于 extern "C" { } 的嵌套过深而报告错误。

这种嵌套是毫无意义的，完全可以通过把#include指令放置在extern "C" { }的外面来避免嵌套。

拿之前的例子来说，如果我们把各个头文件的 #include 指令都移到extern "C" { } 之外，然后使用C++编译器的预处理选项来编译foo.cpp，就会得到下面的结果：

<img src="C:\Users\WangZhe\AppData\Roaming\Typora\typora-user-images\image-20231113215329934.png" alt="image-20231113215329934" style="zoom:50%;" />

把 #include 指令放置在extern "C" { }里面的另外一个重大风险是，你可能会无意中改变一个函数声明的链接规范。

再比如：有两个头文件a.h，b.h，其中b.h包含a.h，如下：

<img src="C:\Users\WangZhe\AppData\Roaming\Typora\typora-user-images\image-20231113215454969.png" alt="image-20231113215454969" style="zoom:50%;" />

此时用C++预处理器展开b.h，将得到

<img src="C:\Users\WangZhe\AppData\Roaming\Typora\typora-user-images\image-20231113215523484.png" alt="image-20231113215523484" style="zoom:50%;" />

按照a.h的本意，函数foo是一个C++自由函数，其链接规范为"C++"。

但在b.h中，由于#include "a.h"被放到了extern "C" { }的内部，函数foo的链接规范被不正确地更改了。

