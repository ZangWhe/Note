### 1 TCP

[一文彻底搞懂 TCP三次握手、四次挥手过程及原理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/108504297)

[计算机网络——TCP的三次握手与四次挥手（超详细） - 特务依昂 - 博客园 (cnblogs.com)](https://www.cnblogs.com/tuyang1129/p/12435772.html#:~:text=2.2 TCP三次握手的过程 1 第一步 ：客户端的 TCP 程序首先向服务器的 TCP,：当客户端接收到 SYNACK 报文段后，它也将为 TCP 连接分配资源（缓存和变量），同时生成一条 SYNACK 报文段的确认报文，并发送给服务器。 )

##### TCP概述

TCP 提供面向有连接的通信传输，面向有连接是指在传送数据之前必须先建立连接，数据传送完成后要释放连接。

无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过**三次握手**进行初始化的。同时由于TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP是**全双工模式**，所以需要**四次挥手**关闭连接。



##### TCP包首部

网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层传过来的数据。

<img src="C:\Users\WangZhe\AppData\Roaming\Typora\typora-user-images\image-20231116211942804.png" alt="image-20231116211942804" style="zoom:50%;" />

下图为TCP首部的规范定义，定义了TCP协议是如何读取和解析数据



<img src="C:\Users\WangZhe\AppData\Roaming\Typora\typora-user-images\image-20231116212115848.png" alt="image-20231116212115848" style="zoom:50%;" />

- **TCP端口号**
  TCP的连接是需要四个要素确定唯一的一个连接：
  **（源IP，源端口号）+ （目地IP，目的端口号）**
  所以TCP首部预留了两个16位作为端口号的存储，而IP地址由上一层IP协议负责传递
  源端口号和目地端口各占16位两个字节，也就是端口的范围是2^16=65535
  另外1024以下是系统保留的，从1024-65535是用户使用的端口范围

- **TCP的序号和确认号**：
  **32位序号 seq**：Sequence number 缩写seq ，TCP通信过程中某一个传输方向上的字节流的每个字节的序号，通过这个来确认发送的数据**有序**，比如现在序列号为1000，发送了1000，下一个序列号就是2000。
  **32位确认号 ack**：Acknowledge number 缩写ack，TCP对上一次seq序号做出的确认号，用来响应TCP报文段，给收到的TCP报文段的序号seq加1。

- **TCP的标志位**
  每个TCP段都有一个目的，这是借助于TCP标志位选项来确定的，允许发送方或接收方指定哪些标志应该被使用，以便段被另一端正确处理。
  用的最广泛的标志是 **SYN**，**ACK** 和 **FIN**，用于建立连接，确认成功的段传输，最后终止连接。

1. **SYN**：简写为`S`，同步标志位，用于建立会话连接，同步序列号；
2. **ACK**： 简写为`.`，确认标志位，对已接收的数据包进行确认；
3. **FIN**： 简写为`F`，完成标志位，表示我已经没有数据要发送了，即将关闭连接；
4. PSH：简写为`P`，推送标志位，表示该数据包被对方接收后应立即交给上层应用，而不在缓冲区排队；
5. RST：简写为`R`，重置标志位，用于连接复位、拒绝错误和非法的数据包；
6. URG：简写为`U`，紧急标志位，表示数据包的紧急指针域有效，用来保证连接不被阻断，并督促中间设备尽快处理；



##### 三次握手

所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个报文。

三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。

**在 socket 编程中，客户端执行 connect() 时。将触发三次握手。**

三次握手示意图如下：

<img src="C:\Users\WangZhe\AppData\Roaming\Typora\typora-user-images\image-20231116212918440.png" alt="image-20231116212918440" style="zoom:50%;" />

- **第一次握手**：
  客户端将TCP报文**标志位SYN置为1**，随机产生一个序号值seq=cliennt_isn，保存在TCP首部的序列号(Sequence Number)字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入`SYN_SENT`状态，等待服务器端确认。



- **第二次握手**：
  服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将TCP报文**标志位SYN和ACK都置为1**，ack=client_isn+1，随机产生一个序号值seq=server_isn，并将该数据包发送给客户端以确认连接请求，服务器端进入`SYN_RCVD`状态。



- **第三次握手**：
  客户端收到确认后，检查ack是否为client_isn+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=server_isn+1，并将该数据包发送给服务器端，

  服务器端检查ack是否为server_isn+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入`ESTABLISHED`状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。



> 注意:上面写的ack和ACK，不是同一个概念：
>
> - 小写的ack代表的是头部的确认号Acknowledge number， 缩写ack，是对上一个包的序号进行确认的号，ack=seq+1。
> - 大写的ACK，则是上面说的TCP首部的标志位，用于标志的TCP包是否对上一个包进行了确认操作，如果确认了，则把ACK标志位设置成1。



##### 四次挥手

四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。

在socket编程中，这一过程由客户端或服务端任一方执行close来触发。

由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。

四次挥手过程的示意图如下：

<img src="C:\Users\WangZhe\AppData\Roaming\Typora\typora-user-images\image-20231116213404067.png" alt="image-20231116213404067" style="zoom:50%;" />

挥手请求可以是Client端，也可以是Server端发起的，我们假设是Client端发起：

- **第一次挥手**： Client端发起挥手请求，向Server端发送标志位是FIN报文段，设置序列号seq，此时，Client端进入`FIN_WAIT_1`状态，这表示Client端没有数据要发送给Server端了。
- **第二次挥手**：Server端收到了Client端发送的FIN报文段，向Client端返回一个标志位是ACK的报文段，ack设为seq加1，Client端进入`FIN_WAIT_2`状态，Server端告诉Client端，我确认并同意你的关闭请求。
- **第三次挥手**： Server端向Client端发送标志位是FIN的报文段，请求关闭连接，同时Client端进入`LAST_ACK`状态。
- **第四次挥手** ： Client端收到Server端发送的FIN报文段，向Server端发送标志位是ACK的报文段，然后Client端进入`TIME_WAIT`状态。Server端收到Client端的ACK报文段以后，就关闭连接。此时，Client端等待**2MSL**的时间后依然没有收到回复，则证明Server端已正常关闭，那好，Client端也可以关闭连接了。



##### **1.1 为什么连接的时候是三次握手，关闭的时候却是四次握手？**

建立连接时因为当Server端收到Client端的SYN连接请求报文后，可以直接发送**SYN+ACK**报文。其中ACK报文是用来应答的，SYN报文是用来同步的。所以建立连接只需要三次握手。

由于TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP是**全双工模式**。这就意味着，关闭连接时，当Client端发出FIN报文段时，只是表示Client端告诉Server端数据已经发送完毕了。当Server端收到FIN报文并返回ACK报文段，表示它已经知道Client端没有数据发送了，但是Server端还是可以发送数据到Client端的，所以Server很可能并不会立即关闭SOCKET，直到Server端把数据也发送完毕。当Server端也发送了FIN报文段时，这个时候就表示Server端也没有数据要发送了，就会告诉Client端，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。



#####  **1.2 为什么是三次握手而不是两次？**

  首先我们要明确，两次握手是必要的。第一次握手，客户端将`SYN`报文发送到服务器，服务器接收到报文后，即可确认客户端到服务器是可达的；而服务器向客户端发送响应的`SYNACK`报文，客户端接收到后，即可确认服务器到客户端也是可达的。至此，连接已经算是建立，那为什么还要有第三次握手呢？

  **主要原因：**客户端和服务器的握手过程，不仅仅是确认互相可达的过程，更重要的是一个**同步**的过程，`SYN`就是同步（Synchronize）的缩写。对于`TCP`报文段来说，**序号**是一个至关重要的部分，它保证了`TCP`传输数据的完整性。而我们上面也说过，`TCP`报文的初始序号不是从`0`开始的，而是一个随机的序号，**而所谓的同步，就是`TCP`客户端和服务器互相同步初始序号的过程**。第一次握手，客户端发送`SYN`报文，将自己的初始序号发送到了服务器，服务器接收到后，向客户端发送`SYNACK`报文段，告诉客户端已经收到了它的初始序号，同时在这个报文段中带上了自己的初始序号。这个时候，第三次握手的作用就出来了：**第三次握手实际上就是客户端在告诉服务器，自己已经收到了它的初始序号，完成了同步，可以开始相互传输数据了**。若没有第三次握手，服务器将无法保证客户端接收到了自己的`SYNACK`报文段，若此时`SYNACK`报文段丢失，客户端不知道服务器的初始序号，将无法处理之后到达客户端的数据。

  **次要原因：**我们假设client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。所以，采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。

​		实际上，上面所述的第一点才是`TCP`三次握手的原因，第二个只能算是顺带的好处吧，从建立连接的报文被称为`SYN`（同步）就可以看出这点。



##### **1.3 主动断开连接的一方为什么要等待2MSL？**

**MSL**：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。

2*MSL = 主动断开连接的一方发送时的MSL + 被动断开连接的一方重传的MSL

<img src="C:\Users\WangZhe\AppData\Roaming\Typora\typora-user-images\image-20231123211907700.png" alt="image-20231123211907700" style="zoom:50%;" />

**有以下两个原因：**

- **第一点：保证TCP协议的全双工连接能够可靠关闭**：
  由于IP协议的不可靠性或者是其它网络原因，导致了Server端没有收到Client端的ACK报文，那么Server端就会在超时之后重新发送FIN，如果此时Client端的连接已经关闭处于`CLOESD`状态，那么重发的FIN就找不到对应的连接了，从而导致连接错乱，所以，Client端发送完最后的ACK不能直接进入`CLOSED`状态，而要保持`TIME_WAIT`，当再次收到FIN时，能够保证对方收到ACK，最后正确关闭连接。
- **第二点：保证这次连接的重复数据段从网络中消失**
  如果Client端发送最后的ACK直接进入`CLOSED`状态，然后又再向Server端发起一个新连接，这时不能保证新连接的与刚关闭的连接的端口号是不同的，也就是新连接和老连接的端口号可能一样了，那么就可能出现问题：如果前一次的连接某些数据滞留在网络中，这些延迟数据在建立新连接后到达Client端，由于新老连接的端口号和IP都一样，TCP协议就认为延迟数据是属于新连接的，新连接就会接收到脏数据，这样就会导致数据包混乱。所以TCP连接需要在TIME_WAIT状态等待2倍MSL，才能保证本次连接的所有数据在网络中消失。



##### 1.4 TCP三次握手过程中可以携带应用层数据吗

[TCP第三次握手能携带数据吗？做个实验就知道！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/373422503)

[TCP连接建立的三次握手过程可以携带数据吗？-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/15118)

**在TCP三次握手过程中，第一次和第二次是不允许携带数据的**

原因是如果可以携带数据的话，首先是连接还未正式建立，此时发送数据是没有意义的，很可能会数据丢失，其次如果有人恶意在第一次握手过程中在SYN 报文中携带大量数据，给服务端大量发送垃圾数据，会导致服务器出现问题。



**TCP标准协议规范中，第三次握手包是允许传输数据的**

因为此时客户端已经处于established状态了



##### 1.5 ACK数据包，消耗TCP的序号吗

在TCP通信中，ACK（Acknowledgment）数据包本身不消耗TCP的序号。

相反，ACK数据包是用来确认已经成功接收到数据的，它包含了对方期望收到的下一个序号。在TCP的序列号机制中，每个TCP报文都有一个序列号字段（Seq），用于标识报文中数据的位置。而ACK字段用于确认收到的数据，指明期望接收的下一个数据的序号。

具体来说，在TCP通信中，发送方发送数据时会设置序列号（Seq），接收方在收到数据后，发送带有ACK标志的确认报文，其中的ACK字段指明期望接收的下一个序号。这样可以确保双方都知道对方已经成功接收了哪些数据，从而保证通信的可靠性。

总的来说，ACK数据包不仅不消耗TCP的序号，反而通过确认序号的方式来维护和确认数据的传输顺序，确保通信的可靠性。



##### 1.6 什么TCP粘包，如何解决

**概述**

在TCP协议中，发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。

**原因**

1. **TCP是面向流的协议：** TCP并不像UDP一样具有消息边界，它是一个字节流协议。发送方的数据在传输过程中被划分为不同的TCP段，而接收方则按照字节流的方式接收。因此，接收方无法知道发送方原始数据块的界限。
2. **网络中的拥塞或延迟：** 在网络中，由于拥塞或延迟等原因，TCP数据包可能会在传输过程中被合并或拆分，从而导致粘包现象。

**解决**

1. **定长消息：** 发送方将消息划分为固定长度的块，确保每个消息都有相同的长度，不足补空字节。接收方按照固定长度来截取消息，从而避免粘包问题。
2. **在消息头部添加消息长度信息：** 发送方在消息头部添加消息的长度信息，接收方首先读取长度信息，然后按照该长度来接收相应长度的数据，确保正确解析每个消息。
3. **使用特定的分隔符：** 发送方在每个消息之间添加特定的分隔符，接收方根据这个分隔符来切分消息。这需要选择一个在实际数据中不会出现的分隔符，以防冲突。
4. **应用层协议处理：** 在应用层设计协议，明确定义消息的格式和传输规则，以确保正确地解析和处理每个消息。



##### 1.7 服务端不进行accept，最多可以有多少个连接建立成功

在TCP协议中，服务器通过`accept`函数来接受客户端的连接请求。如果服务端不调用`accept`，即不接受客户端的连接，那么客户端的连接请求将一直处于等待状态，直到达到操作系统对未处理连接请求的队列的上限。

在常见的操作系统中，有一个参数来限制未处理连接请求的队列的大小，这参数通常被称为`backlog`（等待队列的长度）。

在Linux系统中，`listen`函数用于指定等待队列的长度。当服务端未通过`accept`接受连接时，未处理的连接请求将加入等待队列。如果等待队列已满，新的连接请求将被拒绝。

因此，最多可以有多少个连接建立成功的取决于操作系统和服务器应用程序的配置。默认情况下，操作系统会为等待队列设置一个合理的默认值，但可以通过相应的系统调用参数来进行调整。在实际应用中，需要根据服务器的负载和性能需求来配置等待队列的大小。

> **Linux：** 在Linux系统中，`listen`函数的默认等待队列大小是128。这意味着，如果服务器未及时调用`accept`接受连接，最多有128个连接请求可以在等待队列中排队。
>
> **Windows：** 在Windows操作系统中，TCP套接字的默认等待队列大小通常也是128。



##### 1.8 TCP服务端最多通过三次握手建立多少个TCP连接

> 这题和上题的区别是，这道题是accept之后，最多能接收多少个TCP连接
>
> 也就是一个进程，最多能创建多少个新连接的套接字

可以通过以下命令看到操作系统对于一个进程的最大打开文件描述符的限制”open files“

也就意味着TCP连接的个数取决于操作系统的限制

```shell
ulimit -a
```

![image-20231123205048633](C:\Users\WangZhe\AppData\Roaming\Typora\typora-user-images\image-20231123205048633.png)

也可以通过以下命令对最大打开文件描述符的数量进行修改

```shell
ulimit -n <new_limit>
```



##### 1.9 三次握手中为什么需要协商MSS

MSS（Maximum Segment Size，最大报文长度），是TCP协议定义的一个选项，MSS选项用于在TCP连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度。

也就是TCP给网络层的而数据大小最大就是MSS个字节



协商原因：

- 原因一：防止数据包过大，在网络层被IP协议分片传输，IP协议是不可靠协议，如果一个分片丢失，对于TCP而言就是整条数据包丢失，那么TCP就要重传整个数据包
- 原因二：越丢包，越重传；越重传，网络转发能力越不行；造成恶性循环
- 原因三：TCP交给网络层IP协议的数据包符合MSS，则IP协议一定不会分片传输。

> 数据链路层MTU和MSS的关系：
>
> MSS + TCP首部 + IP首部 <= MTU
>
> 所以MSS一定小于MTU



##### 1.10 四次握手阶段可以发送应用层数据吗？

可以，在第二次挥手之后，被动断开连接的一方可以给主动断开连接的一方发送数据



##### 1.11 四次挥手中服务端出现大量close_wait状态，什么原因？有什么危害？怎么办？

**问题解析**

- 首先，close_wait状态，存在于被动断开连接的一方
- 其次，客户端和服务端都可以先发起断开连接，所以，都有可能存在close_wait状态
- 再次，服务端出现大量close_wait状态，说明服务端是被动断开连接的一方
- 最后，被动断开连接的一方，发送了第三次挥手的FIN报文后，状态才会从close_wait状态变为LASK_ACK状态

**问题转换**

被动断开连接的服务端，为什么不发送第三次挥手的报文

👇

然后是，被动断开连接的服务段需要怎么做才能发送FIN报文

👇

再然后是，被动断开的一方在调用close函数后，关闭了套接字之后，TCP才会发送第三次挥手的FIN报文

👇

最后是，为什么被动断开连接的服务端，不调用close函数，关闭掉已经在四次挥手过程中的连接？



**原因**

原因是开放的：

1. 可能是服务端的线程阻塞了，无法调用close函数
2. 在close之前有大量耗时的逻辑需要执行
3. ......



**危害**

服务端没有释放文件描述符，导致资源被浪费



---

##### 1.12 SYN报文在什么情况下会被丢弃



**原因**

- 原因一：TCP两个队列满了（半连接队列和全连接队列），造成SYN报文被丢弃
- 原因二：开启tcp_tw_recycke参数，并且在NAT环境下，造成SYN报文被丢弃



> 先只了解队满的情况



在TCP三次握手的时候，Linux内核会维护两个队列

分别是：

- 半连接队列：也称未完成连接队列
- 全连接队列：也称已完成连接队列

> **回顾三次握手的知识：**
>
> - 服务端收到客户端发起的SYN请求，内核会把该连接存储到半连接队列中，并向客户端响应SYN+ACK
> - 然后服务端会返回ACK，服务端在收到第三次握手的ACK后，内核会把连接从半连接队列移除
> - 然后创建新的完全的连接，并将其添加到全连接队列中，等待进程调用accept函数取出连接
>
> ![image-20231123214511953](C:\Users\WangZhe\AppData\Roaming\Typora\typora-user-images\image-20231123214511953.png)

**第一种情况：半连接队列满了**

原因：大量的SYN数据包，同时到达服务端，导致半连接队列瞬间队满，导致多余的SYN就被丢弃了

> SYN泛洪攻击：大量无意义的SYN发送到服务方

**解决方法：**

- 增大半连接队列：需要同时增大半连接队列和全连接队列，也就是半连接队列的tcp_max_backlog和全连接队列的somaxconn和backlog都要增加

  <img src="C:\Users\WangZhe\AppData\Roaming\Typora\typora-user-images\image-20231123215812958.png" alt="image-20231123215812958" style="zoom:50%;" />

- 开启tcp_syncookies功能

- 减少SYN+ACK重传次数

**第二种情况：全连接队列满了**

在服务端并发处理大量请求时，如果TCP 全连接队列过小，或者应用程序调用accept()不及时，就会造成队满，这时后续的连接就会被丢弃，会导致服务端请求数量上不去的现象

**解决方法：**

- 增大全连接队列的最大长度：增加backlog和somaxconn参数
- 检查系统或代码为什么没能及时调用accept()



##### 1.13 TCP协议的序号的值最大是多少，超过该最大值后，序号的值会变成多少？

用TCP协议进行数据传输时，每个TCP报文段都包含一个32位的序号字段，用于表示报文段中的数据在整个数据流中的位置。

<img src="C:\Users\WangZhe\AppData\Roaming\Typora\typora-user-images\image-20231116212115848.png" alt="image-20231116212115848" style="zoom:50%;" />

- TCP序号字段的最大值是2^32-1,这是一个无符号整数，表示的范围是0~2^32-1
- 当到达最大值后，序号会循环到0，这个现象成为”序号回绕“。这个机制可以确保TCP连接在长时间运行后仍能正确处理序号，而不会发生溢出或混淆





##### 1.14 什么是确认应答机制

确认应答机制：发送方发送一个数据给接收方，接收方回复一个确认给发送方

本质：TCP的确认本质上是对序号的确认，序号的背后就是数据

确认应答的目的就是为了保证数据的可靠传输，也就是回复的确认应答的数字表示，这个数字之前的数据已经接收到了



##### 1.15 什么是超时重传机制

超时重传机制：在发送数据时，设置一个定时器，当超过指定的时间后，没有收到对方的`ACK`确认应答报文，就会重发该数据。

1）数据包丢失

发送发发送的数据包丢失，也就是接收方没有收到数据包

2）确认应答丢失

接收方回复的确认报文丢失，也就是发送方没有收到确认报文



##### 1.16 超时重传的时间是固定的吗？怎么计算的？

1）超时重传时间RTO不可以固定

- 当RTO较大时，重发的时间就会很慢，会导致效率低，性能差
- 当RTO较小时，当传输较慢时，会导致可能并没有丢就重发，于是会导致重发的很快，会增加网络堵塞，导致更多的超时，造成恶性循环



2）计算

TCP超时与重传中一个很最重要的部分是对一个给定连接的往返时间（RTT）的测量。由于网络流量的变化，

这个时间会相应地发生改变，TCP需要跟踪这些变化并动态调整超时时间RTO。

> RTT指的是数据包`发送时刻`到`接收确认时刻`的差值，也就是数据包的往返时间



##### 1.17 什么是快重传

> - 快重传是为了在没有除法超时重传的时候，就触发发送方传递数据
> - 快重传本质上是为了提高传输效率

发送方收到**三次同样的确认**之后，就会立刻重传丢失的报文

![image-20231126220142965](https://raw.githubusercontent.com/ZangWhe/image/main/202311262201056.png)

##### 1.18 快重传存在效率问题，以及如何解决

**问题**

在传统的TCP协议中，当接收方检测到丢失的数据包时，它只能发送单个累积确认（ACK），通知发送方它成功接收的最后一个有序数据包的序列号。发送方在收到这个确认后，会认为之前的数据包都已经成功到达，然后进行相应的重传。这种方式存在一些问题：

1. **全局重传：** 如果窗口中的某个数据包丢失，传统的TCP会进行全局重传，即重传窗口中的所有数据包。这样会浪费带宽和处理资源，尤其是在高速网络中，因为可能只有一小部分数据包丢失。

**解决**

SACK（Selective Acknowledgment，选择性确认）是TCP协议中的一种扩展选项，用于在传输过程中向发送端报告已成功接收的数据段的情况。SACK允许接收端不仅确认已经收到的数据，还能指明未收到的部分，从而提供更灵活的重传机制。

在快速重传的背景下，SACK的引入使得选择性重传成为可能。当接收方检测到某些数据段丢失时，它可以使用SACK选项通知发送端有关哪些数据段未收到。这样，发送端就可以有选择性地重传仅丢失的那些数据段，而不需要重传整个窗口的数据。

SACK选项的格式如下：

```
  +--------+--------+--------------+------------+
  |   Kind |Length  |  Left Edge   | Right Edge |
  +--------+--------+--------------+------------+
```

- **Kind:** 选项类型，SACK的值为5。
- **Length:** 选项的长度，指示后续字段的字节数。
- **Left Edge 和 Right Edge:** 这两个字段标识了已成功接收的数据段的范围，表示数据段的左边缘和右边缘。

通过SACK选项，TCP发送方可以更加智能地进行重传，只针对未成功传输的数据段进行处理，而不是简单地重传所有数据。这提高了网络的效率，特别是在面对丢失或乱序的情况下。

需要注意的是，不是所有的TCP连接都支持SACK选项，因此在使用时需要确保连接的两端都能正确处理和支持SACK。



---



### 网页输入一个 URL 并回车到显示网页、这个过程发生了什么

[在浏览器输入 URL 回车之后发生了什么（超详细版） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/80551769)

[从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！ | Dailc的个人主页 (dailichun.com)](http://www.dailichun.com/2018/03/12/whenyouenteraurl.html)

1. **URL解析：** 统一资源定位符。

   ```
   URL一般包括几大部分：
   
   - protocol，协议头，譬如有http，ftp，https等
   - host，主机域名或IP地址
   - port，端口号
   - path，目录路径
   - query，即查询参数
   - fragment，即#后的hash值，一般用来定位到某个位置
   ```

   

2. **DNS解析：** 浏览器需要将主机名解析为相应的IP地址。
   它通过向域名系统（DNS）服务器发出请求来获取主机名对应的IP地址。这个过程可能涉及本地DNS缓存、浏览器缓存或者递归地向DNS服务器发出查询。
   <img src="C:\Users\WangZhe\AppData\Roaming\Typora\typora-user-images\image-20231121210607387.png" alt="image-20231121210607387" style="zoom:100%;" />

   > ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。

3. **建立TCP连接：** 使用解析得到的IP地址和端口号，浏览器尝试与目标服务器建立TCP连接。如果使用的是HTTPS协议，还需要进行SSL/TLS握手过程来建立安全连接。

   在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。

   

4. **发起HTTP请求：** 一旦TCP连接建立，浏览器向服务器发送HTTP请求。这个请求包括请求方法（GET、POST等）、路径、HTTP版本、请求头部（例如，用户代理、Accept等）、可能的请求体（对于POST请求）等信息。

   ```
   1.应用层(dns,http) DNS解析成IP并发送http请求
   
   2.传输层(tcp,udp) 建立tcp连接（三次握手）
   
   3.网络层(IP,ARP) IP寻址
   
   4.数据链路层(PPP) 封装成帧
   
   5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）
   ```

   

5. **服务器处理请求：** 服务器接收到浏览器的请求后，根据请求的内容和路径等信息，处理并准备响应。

6. **服务器发送HTTP响应：** 服务器将HTTP响应发送回浏览器。响应包括状态码（表示请求成功、重定向、服务器错误等）、响应头部（包含服务器信息、内容类型等）、以及响应体（实际的网页内容）。

7. **浏览器渲染：** 浏览器接收到服务器的响应后，根据响应的内容类型（例如，HTML、CSS、JavaScript等），进行页面的渲染。浏览器会解析HTML文档，加载并解析CSS样式表，执行JavaScript代码，最终在用户界面上呈现出完整的网页。

8. **显示网页：** 最终，浏览器将渲染好的网页显示在用户界面上，用户可以与页面进行交互。









---



### ARP协议

ARP（Address Resolution Protocol）是一种用于解析网络层地址（通常是IPv4地址）到物理网络地址（通常是MAC地址）的协议。在TCP/IP网络中，设备通常使用IP地址来标识自己，而在局域网（LAN）上，设备之间的通信实际上是通过物理地址（MAC地址）进行的。ARP协议帮助在这两种地址之间建立映射关系。

ARP的主要功能包括：

1. **IP到MAC地址的解析：** 当一个设备知道目标的IP地址但不知道其MAC地址时，它可以使用ARP请求广播来询问局域网上的其他设备：“谁知道这个IP地址对应的MAC地址？”目标设备会收到这个ARP请求并回复包含自己MAC地址的ARP响应。
2. **ARP缓存：** 为了提高效率，设备通常会在一个ARP缓存表中保存最近的IP地址到MAC地址的映射关系。当设备需要进行通信时，它首先查看本地的ARP缓存表，如果有对应的映射关系，就不需要发送ARP请求，直接使用缓存中的信息。

ARP工作在网络层和数据链路层之间，负责将网络层的IP地址映射到数据链路层的MAC地址。ARP使用广播方式发送请求，因为在局域网上，广播是一种将消息发送到所有设备的有效方式。一旦设备获得了IP地址到MAC地址的映射关系，它就可以在数据链路层上直接发送数据帧到目标设备。

总体而言，ARP协议是TCP/IP协议族中的一个重要组成部分，它确保了在局域网上设备之间能够正确地建立IP地址到MAC地址的映射，从而实现有效的通信。



---



